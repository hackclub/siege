<% content_for :body_class, "catacombs-page" %>

<% content_for :head do %>
  <style>
    @font-face {
      font-family: 'Siege Glyph';
      src: url('<%= asset_path("SiegeGlyphs-Regular.otf") %>') format('opentype');
      font-weight: normal;
      font-style: normal;
    }

    html, body {
      overflow: hidden;
    }
    
    .catacombs-page .navbar-nav > :not(:first-child) {
      display: none;
    }
    
    .catacombs-container {
      width: 100vw;
      background: transparent;
      overflow: hidden;
    }
    
    .catacombs {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100vw;
      height: 100vh;
    }
    
    .catacombs-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      object-fit: cover;
      transition: filter 0.3s ease;
    }

    .catacombs-layer:nth-child(1) { z-index: 1; }
    .catacombs-layer:nth-child(2) { z-index: 2; }
    .catacombs-layer:nth-child(3) { z-index: 3; }
    .catacombs-layer:nth-child(4) { z-index: 4; }
    .catacombs-layer:nth-child(5) { z-index: 5; }
    .catacombs-layer:nth-child(6) { z-index: 6; }

    .catacombs-layer.highlighted {
      filter: drop-shadow(4px 0 0 rgba(191, 177, 131, 0.8)) drop-shadow(-4px 0 0 rgba(191, 177, 131, 0.8)) drop-shadow(0 4px 0 rgba(191, 177, 131, 0.8)) drop-shadow(0 -4px 0 rgba(245, 231, 183, 0.8));
    }

    .hover-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 300;
    }
    
    .hover-box {
      position: absolute;
      pointer-events: none;
    }
    
    .hover-box svg {
      width: 100%;
      height: 100%;
      pointer-events: auto;
    }
    
    .hover-box svg path,
    .hover-box svg circle,
    .hover-box svg rect,
    .hover-box svg polygon {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .hover-box svg path:hover,
    .hover-box svg circle:hover,
    .hover-box svg rect:hover,
    .hover-box svg polygon:hover {
      opacity: 0.8;
    }

    .mystereeple-dialogue {
      position: fixed;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      padding: 40px;
      background: rgba(171, 171, 171, 0.95);
      border: 3px solid #402b20;
      z-index: 1000;
      display: none;
    }

    .mystereeple-dialogue.visible {
      display: block;
    }

    .mystereeple-dialogue-text {
      font-family: "IM Fell English", serif;
      font-size: 20px;
      color: #402b20;
      text-align: center;
      margin-bottom: 30px;
      line-height: 1.5;
    }

    .mystereeple-dialogue-buttons {
      display: none;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
    }

    .mystereeple-dialogue-buttons.visible {
      display: flex;
    }

    .mystereeple-dialogue-button {
      padding: 10px 30px;
      background: #402b20;
      color: #f5e7b7;
      border: 2px solid #402b20;
      font-family: "IM Fell English", serif;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mystereeple-dialogue-button:hover {
      background: #f5e7b7;
      color: #402b20;
    }

    .betting-interface {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 700px;
      padding: 40px;
      background: rgba(171, 171, 171, 0.95);
      border: 3px solid #402b20;
      z-index: 1000;
      display: none;
    }

    .betting-interface.visible {
      display: block;
    }

    .betting-header {
      position: relative;
      margin-bottom: 30px;
    }

    .betting-title {
      font-family: "Jaini", "IM Fell English", serif;
      font-size: 32px;
      color: #402b20;
      text-align: center;
    }

    .betting-mode-switch {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      padding: 8px 20px;
      background: #402b20;
      color: #f5e7b7;
      border: 2px solid #402b20;
      font-family: "IM Fell English", serif;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .betting-mode-switch:hover {
      background: #f5e7b7;
      color: #402b20;
    }

    .betting-coins-display {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: "IM Fell English", serif;
      font-size: 20px;
      font-weight: 700;
      color: #402b20;
    }

    .betting-coin-icon {
      width: 32px;
      height: 32px;
    }

    .bet-panels {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
    }

    .bet-panel {
      flex: 1;
      padding: 20px;
      background: #f5e7b7;
      border: 3px solid #402b20;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .bet-panel:hover {
      background: #e8d9a3;
      transform: translateY(-2px);
    }

    .bet-panel.selected {
      background: #402b20;
      color: #f5e7b7;
    }

    .bet-panel-hours {
      font-family: "Jaini", "IM Fell English", serif;
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .bet-panel-multiplier {
      font-family: "IM Fell English", serif;
      font-size: 18px;
    }

    .bet-slider-container {
      margin-bottom: 30px;
    }

    .bet-slider-label {
      font-family: "IM Fell English", serif;
      font-size: 20px;
      color: #402b20;
      text-align: center;
      margin-bottom: 15px;
    }

    .bet-slider {
      width: 100%;
      height: 8px;
      background: #d3d3d3;
      outline: none;
      -webkit-appearance: none;
    }

    .bet-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #402b20;
      cursor: pointer;
      border-radius: 50%;
    }

    .bet-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      background: #402b20;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .betting-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .betting-button {
      padding: 10px 30px;
      background: #402b20;
      color: #f5e7b7;
      border: 2px solid #402b20;
      font-family: "IM Fell English", serif;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .betting-button:hover {
      background: #f5e7b7;
      color: #402b20;
    }

    .betting-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .shop-interface {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 700px;
      max-height: 80vh;
      padding: 40px;
      background: rgba(171, 171, 171, 0.95);
      border: 3px solid #402b20;
      z-index: 1000;
      display: none;
      overflow-y: auto;
    }

    .shop-interface.visible {
      display: block;
    }

    .shop-items-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .shop-item-card {
      background: #f5e7b7;
      border: 3px solid #402b20;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .shop-item-card:hover {
      background: #e8d9a3;
    }

    .shop-item-card.disabled {
      opacity: 0.5;
      cursor: pointer;
    }

    .shop-item-image {
      width: 100%;
      height: 100px;
      object-fit: contain;
      margin-bottom: 0.5rem;
    }

    .shop-item-name {
      font-family: "IM Fell English", serif;
      font-weight: 700;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .shop-item-cost {
      font-family: "IM Fell English", serif;
      color: #8b5a3c;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .shop-item-stock {
      font-size: 0.9rem;
      color: #6b5b4a;
    }

    .shop-item-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      padding: 2rem;
      background: rgba(255, 255, 255, 0.95);
      border: 3px solid #402b20;
      z-index: 1100;
      display: none;
    }

    .shop-item-modal.visible {
      display: block;
    }

    .shop-item-modal-image {
      width: 100%;
      max-height: 200px;
      object-fit: contain;
      margin-bottom: 1rem;
    }

    .shop-item-modal-title {
      font-family: "Jaini", "IM Fell English", serif;
      font-size: 24px;
      text-align: center;
      margin-bottom: 1rem;
      color: #402b20;
    }

    .shop-item-modal-description {
      font-family: "IM Fell English", serif;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 1rem;
      color: #402b20;
    }

    .shop-item-modal-price {
      font-family: "IM Fell English", serif;
      font-size: 20px;
      text-align: center;
      margin-bottom: 1rem;
      color: #8b5a3c;
      font-weight: 700;
    }

    .shop-item-modal-stock {
      text-align: center;
      margin-bottom: 1.5rem;
      color: #6b5b4a;
    }

    .shop-modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    .global-betting-content {
      display: none;
    }

    .global-betting-content.visible {
      display: block;
    }

    .personal-betting-content {
      display: block;
    }

    .personal-betting-content.hidden {
      display: none;
    }

    .global-stat {
      font-family: "IM Fell English", serif;
      font-size: 18px;
      color: #402b20;
      text-align: center;
      margin-bottom: 20px;
    }

    .global-stat-value {
      font-weight: 700;
      font-size: 22px;
    }

    .global-prediction {
      margin-bottom: 30px;
    }

    .global-prediction-label {
      font-family: "IM Fell English", serif;
      font-size: 20px;
      color: #402b20;
      text-align: center;
      margin-bottom: 10px;
    }

    .global-prediction-value {
      font-size: 24px;
      font-weight: 700;
      color: #402b20;
    }

    .global-multiplier {
      font-family: "IM Fell English", serif;
      font-size: 18px;
      color: #402b20;
      text-align: center;
      margin-top: 10px;
    }

    .global-multiplier-value {
      font-weight: 700;
      font-size: 22px;
      color: #8b5a3c;
    }

    .global-payout {
      font-family: "IM Fell English", serif;
      font-size: 20px;
      color: #402b20;
      text-align: center;
      margin-bottom: 30px;
    }

    .global-payout-value {
      font-weight: 700;
      font-size: 24px;
      color: #8b5a3c;
    }

    .glyph-display {
      position: fixed;
      color: rgba(245, 231, 183, 0.9);
      z-index: 50;
      pointer-events: none;
      white-space: nowrap;
      display: flex;
      gap: 0.4em;
      align-items: flex-start;
      height: 60px;
    }

    .glyph-char {
      display: inline-block;
			font-family: 'Siege Glyph', monospace;
      line-height: 1;
      position: relative;
      width: 1ch;
      text-align: center;
    }

    .bet-progress {
      margin: 30px 0;
    }

    .bet-progress-label {
      font-family: "IM Fell English", serif;
      font-size: 18px;
      color: #402b20;
      text-align: center;
      margin-bottom: 10px;
    }

    .bet-progress-bar {
      width: 100%;
      height: 30px;
      background: #d3d3d3;
      border: 2px solid #402b20;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .bet-progress-fill {
      height: 100%;
      background: #8b5a3c;
      transition: width 0.3s ease;
    }

    .bet-progress-text {
      font-family: "IM Fell English", serif;
      font-size: 18px;
      color: #402b20;
      text-align: center;
      font-weight: 700;
    }


  </style>
<% end %>

<div class="catacombs-container">
  <div class="catacombs">
    <%= image_tag "catacombs/catacombs-bg.webp", class: "catacombs-layer" %>
    <%= image_tag "catacombs/catacombs-lines.webp", class: "catacombs-layer" %>
    <% if @emerald_unlocked %>
      <%= image_tag "catacombs/catacombs-emerald.webp", class: "catacombs-layer" %>
    <% end %>
    <% if @ruby_unlocked %>
      <%= image_tag "catacombs/catacombs-ruby.webp", class: "catacombs-layer" %>
    <% end %>
    <% if @amethyst_unlocked %>
      <%= image_tag "catacombs/catacombs-amethyst.webp", class: "catacombs-layer" %>
    <% end %>
    <% if @mystereeple_visible %>
      <%= image_tag "catacombs/catacombs-mystereeple.webp", class: "catacombs-layer mystereeple" %>
    <% end %>
  </div>
</div>
<div class="hover-overlay">
  <!-- Hover boxes will be generated by JavaScript -->
</div>

<div class="glyph-display" id="glyph-display"></div>

<div class="mystereeple-dialogue" id="mystereeple-dialogue">
  <div class="mystereeple-dialogue-text" id="mystereeple-text"></div>
  <div class="mystereeple-dialogue-buttons" id="mystereeple-buttons"></div>
</div>

<% if @available_windows.any? { |w| w.window_type == 'betting' } %>
<div class="betting-interface" id="betting-interface">
  <div class="betting-header">
    <div class="betting-coins-display">
      <%= image_tag "coin.png", class: "betting-coin-icon" %>
      <span id="user-coins-display">0</span>
    </div>
    <h2 class="betting-title" id="betting-title"><%= @personal_bet ? "Your personal bet" : "Place a personal bet" %></h2>
    <button class="betting-mode-switch" id="betting-mode-toggle" onclick="toggleBettingMode()">Global</button>
  </div>
  
  <% if @personal_bet %>
    <div class="personal-betting-content" id="personal-betting-content">
      <div class="bet-info">
        <div class="global-stat">Goal: <span class="global-stat-value"><%= @personal_bet.hours_goal %>h</span></div>
        <div class="global-stat">Coins bet: <span class="global-stat-value"><%= @personal_bet.coin_amount.to_i %></span></div>
        <div class="global-payout">Estimated payout: <span class="global-payout-value"><%= @personal_bet.estimated_payout.to_i %></span> coins</div>
        
        <div class="bet-progress">
          <div class="bet-progress-label">Your progress:</div>
          <div class="bet-progress-bar">
            <div class="bet-progress-fill" style="width: <%= [(@current_week_hours / @personal_bet.hours_goal * 100).round(1), 100].min %>%"></div>
          </div>
          <div class="bet-progress-text"><%= @current_week_hours %>h / <%= @personal_bet.hours_goal %>h</div>
        </div>
        
        <div class="betting-actions">
          <% if @current_week_hours >= @personal_bet.hours_goal %>
            <button class="betting-button" id="collect-personal-bet-btn" onclick="collectPersonalBet()" <%= 'disabled' if @personal_bet.paid_out? %>>
              <%= @personal_bet.paid_out? ? 'Collected' : 'Collect Bet' %>
            </button>
          <% end %>
          <button class="betting-button" onclick="closeBettingInterface()">Close</button>
        </div>
      </div>
    </div>
  <% else %>
    <div class="personal-betting-content" id="personal-betting-content">
    <% unless @is_betting_day %>
      <div style="text-align: center; padding: 2rem;">
        <p style="font-size: 1.2rem; color: #402b20; margin-bottom: 1rem;">Betting is only available Monday through Thursday.</p>
        <p style="color: #6b5b4a;">Come back on Monday to place your bet!</p>
        <div class="betting-actions" style="margin-top: 2rem;">
          <button class="betting-button" onclick="closeBettingInterface()">Close</button>
        </div>
      </div>
    <% else %>
    <div class="bet-panels">
    <div class="bet-panel" data-hours="15" data-multiplier="1.5" onclick="selectBetPanel(this)">
      <div class="bet-panel-hours">15h</div>
      <div class="bet-panel-multiplier">1.5x multiplier</div>
    </div>
    <div class="bet-panel" data-hours="20" data-multiplier="2" onclick="selectBetPanel(this)">
      <div class="bet-panel-hours">20h</div>
      <div class="bet-panel-multiplier">2x multiplier</div>
    </div>
    <div class="bet-panel" data-hours="25" data-multiplier="3" onclick="selectBetPanel(this)">
      <div class="bet-panel-hours">25h</div>
      <div class="bet-panel-multiplier">3x multiplier</div>
    </div>
  </div>
  
  <div class="bet-slider-container">
    <div class="bet-slider-label">Bet Amount: <span id="bet-amount-display">25</span> coins</div>
    <input type="range" min="1" max="50" value="25" class="bet-slider" id="bet-slider" oninput="updateBetAmount(this.value)">
  </div>
  
    <div class="global-payout">
      Estimated payout: <span class="global-payout-value" id="personal-payout-display">38</span> coins
    </div>
  
    <div class="betting-actions">
      <button class="betting-button" id="submit-bet-button" onclick="submitBet()" disabled>Place Bet</button>
      <button class="betting-button" onclick="closeBettingInterface()">Cancel</button>
    </div>
    </div>
    <% end %>
  <% end %>

  <% if @global_bet %>
    <div class="global-betting-content" id="global-betting-content">
      <div class="bet-info">
        <div class="global-stat">Your prediction: <span class="global-stat-value"><%= @global_bet.predicted_hours.to_i %></span>h</div>
        <div class="global-stat">Coins bet: <span class="global-stat-value"><%= @global_bet.coin_amount.to_i %></span></div>
        <div class="global-payout">Estimated payout: <span class="global-payout-value"><%= @global_bet.estimated_payout.to_i %></span> coins</div>
        
        <div class="bet-progress">
          <div class="bet-progress-label">Global progress:</div>
          <div class="bet-progress-bar">
            <div class="bet-progress-fill" style="width: <%= [(@current_global_hours / @global_bet.predicted_hours * 100).round(1), 100].min %>%"></div>
          </div>
          <div class="bet-progress-text"><%= @current_global_hours %>h / <%= @global_bet.predicted_hours.to_i %>h</div>
        </div>
        
        <div class="betting-actions">
          <% if @current_global_hours >= @global_bet.predicted_hours %>
            <button class="betting-button" id="collect-global-bet-btn" onclick="collectGlobalBet()" <%= 'disabled' if @global_bet.paid_out? %>>
              <%= @global_bet.paid_out? ? 'Collected' : 'Collect Bet' %>
            </button>
          <% end %>
          <button class="betting-button" onclick="closeBettingInterface()">Close</button>
        </div>
      </div>
    </div>
  <% else %>
    <div class="global-betting-content" id="global-betting-content">
    <% unless @is_betting_day %>
      <div style="text-align: center; padding: 2rem;">
        <p style="font-size: 1.2rem; color: #402b20; margin-bottom: 1rem;">Betting is only available Monday through Thursday.</p>
        <p style="color: #6b5b4a;">Come back on Monday to place your bet!</p>
        <div class="betting-actions" style="margin-top: 2rem;">
          <button class="betting-button" onclick="closeBettingInterface()">Close</button>
        </div>
      </div>
    <% else %>
    <div class="global-stat">
      Hours shipped last week: <span class="global-stat-value" id="last-week-hours">Loading...</span>
    </div>
    
    <div class="global-prediction">
      <div class="global-prediction-label">
        Your prediction: <span class="global-prediction-value" id="hours-prediction-display">1000</span>h
      </div>
      <input type="range" min="1" max="2000" value="1000" class="bet-slider" id="hours-prediction-slider" oninput="updateHoursPrediction(this.value)">
      <div class="global-multiplier">
        Multiplier: <span class="global-multiplier-value" id="global-multiplier-display">1.5x</span>
      </div>
    </div>
    
    <div class="bet-slider-container">
      <div class="bet-slider-label">Bet Amount: <span id="global-bet-amount-display">25</span> coins</div>
      <input type="range" min="1" max="200" value="25" class="bet-slider" id="global-bet-slider" oninput="updateGlobalBetAmount(this.value)">
    </div>
    
    <div class="global-payout">
      Estimated payout: <span class="global-payout-value" id="global-payout-display">38</span> coins
    </div>
    
    <div class="betting-actions">
      <button class="betting-button" id="submit-global-bet-button" onclick="submitGlobalBet()">Place Bet</button>
      <button class="betting-button" onclick="closeBettingInterface()">Cancel</button>
    </div>
    </div>
    <% end %>
  <% end %>
</div>
<% end %>

<% if @available_windows.any? { |w| w.window_type == 'shop' } %>
<div class="shop-interface" id="shop-interface">
  <div class="betting-header">
    <div class="betting-coins-display">
      <%= image_tag "coin.png", class: "betting-coin-icon" %>
      <span id="shop-user-coins-display">0</span>
    </div>
    <h2 class="betting-title">Mystereeple Shop</h2>
    <button class="betting-mode-switch" onclick="closeShopInterface()">×</button>
  </div>
  
  <div class="shop-items-grid" id="shop-items-grid">
    <p style="text-align: center; grid-column: 1/-1;">Loading...</p>
  </div>
</div>

<div class="shop-item-modal" id="shop-item-modal">
  <div id="shop-modal-content"></div>
</div>
<% end %>

<script>
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

async function loadShopItems() {
  try {
    const response = await fetch('/catacombs/shop_items');
    const data = await response.json();
    
    userCoins = data.user_coins || 0;
    document.getElementById('shop-user-coins-display').textContent = userCoins;
    
    const grid = document.getElementById('shop-items-grid');
    grid.innerHTML = '';
    
    if (data.items.length === 0) {
      grid.innerHTML = '<p style="text-align: center; grid-column: 1/-1;">No items available</p>';
      return;
    }
    
    data.items.forEach(item => {
      const card = document.createElement('div');
      card.className = 'shop-item-card';
      const canPurchase = item.remaining > 0 && item.cost <= userCoins;
      
      if (!canPurchase) {
        card.classList.add('disabled');
      }
      
      card.onclick = () => showItemModal(item, canPurchase);
      
      card.innerHTML = `
        ${item.image_url ? `<img src="${escapeHtml(item.image_url)}" class="shop-item-image" alt="${escapeHtml(item.name)}">` : ''}
        <div class="shop-item-name">${escapeHtml(item.name)}</div>
        <div class="shop-item-cost">${escapeHtml(String(item.cost))} coins</div>
        <div class="shop-item-stock">${escapeHtml(String(item.remaining))} left</div>
      `;
      
      grid.appendChild(card);
    });
  } catch (error) {
    console.error('Error loading shop items:', error);
    document.getElementById('shop-items-grid').innerHTML = '<p style="text-align: center; grid-column: 1/-1;">Failed to load items</p>';
  }
}

async function purchaseShopItem(itemId, cost, name) {
  if (cost > userCoins) {
    showModalAlert('Not enough coins!', 'Error');
    return;
  }
  
  // Show processing modal
  const modal = document.getElementById('shop-item-modal');
  const content = document.getElementById('shop-modal-content');
  content.innerHTML = `
    <h2 class="shop-item-modal-title">Processing Purchase...</h2>
    <p style="text-align: center; color: #402b20;">Please wait...</p>
  `;
  
  try {
    const response = await fetch('/catacombs/purchase_shop_item', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ item_id: itemId })
    });
    
    const data = await response.json();
    
    if (data.success) {
      userCoins = data.new_balance;
      document.getElementById('shop-user-coins-display').textContent = userCoins;
      document.getElementById('user-coins-display').textContent = userCoins;
      
      // Show success and reload shop
      content.innerHTML = `
        <h2 class="shop-item-modal-title">Purchase Complete!</h2>
        <p style="text-align: center; color: #402b20; margin-bottom: 2rem;">You purchased ${escapeHtml(name)}</p>
        <div class="shop-modal-actions">
          <button class="betting-button" onclick="closeItemModal(); loadShopItems();">Close</button>
        </div>
      `;
    } else {
      showModalAlert(data.message, 'Error');
      modal.classList.remove('visible');
    }
  } catch (error) {
    console.error('Error purchasing item:', error);
    showModalAlert('Failed to purchase item', 'Error');
    modal.classList.remove('visible');
  }
}

function closeShopInterface() {
  document.getElementById('shop-interface').classList.remove('visible');
}

function showItemModal(item, canPurchase) {
  const modal = document.getElementById('shop-item-modal');
  const content = document.getElementById('shop-modal-content');
  
  let purchaseButton = '';
  const escapedName = escapeHtml(item.name).replace(/'/g, "\\'");
  if (canPurchase) {
    purchaseButton = `<button class="betting-button" onclick="purchaseShopItemFromModal(${item.id}, ${item.cost}, '${escapedName}')">Purchase for ${escapeHtml(String(item.cost))} coins</button>`;
  } else if (item.remaining <= 0) {
    purchaseButton = `<button class="betting-button" disabled>Out of Stock</button>`;
  } else {
    purchaseButton = `<button class="betting-button" disabled>Need ${escapeHtml(String(item.cost - userCoins))} more coins</button>`;
  }
  
  content.innerHTML = `
    ${item.image_url ? `<img src="${escapeHtml(item.image_url)}" class="shop-item-modal-image" alt="${escapeHtml(item.name)}">` : ''}
    <h2 class="shop-item-modal-title">${escapeHtml(item.name)}</h2>
    <div class="shop-item-modal-description">${escapeHtml(item.description || 'No description available')}</div>
    <div class="shop-item-modal-price">${escapeHtml(String(item.cost))} coins</div>
    <div class="shop-item-modal-stock">${escapeHtml(String(item.remaining))} left</div>
    <div class="shop-modal-actions">
      ${purchaseButton}
      <button class="betting-button" onclick="closeItemModal()">Close</button>
    </div>
  `;
  
  modal.classList.add('visible');
}

function closeItemModal() {
  document.getElementById('shop-item-modal').classList.remove('visible');
}

async function purchaseShopItemFromModal(itemId, cost, name) {
  await purchaseShopItem(itemId, cost, name);
  // Don't close modal - purchaseShopItem handles showing success message
}

</script>
<script>
let typingInProgress = false;
let currentTypingTimeout = null;

function typeText(element, text, speed = 50) {
  return new Promise((resolve, reject) => {
    // Clear any existing typing
    if (currentTypingTimeout) {
      clearTimeout(currentTypingTimeout);
    }
    
    element.textContent = '';
    let index = 0;
    typingInProgress = true;
    
    function type() {
      if (!typingInProgress) {
        reject('cancelled');
        return;
      }
      
      if (index < text.length) {
        element.textContent += text.charAt(index);
        index++;
        currentTypingTimeout = setTimeout(type, speed);
      } else {
        typingInProgress = false;
        currentTypingTimeout = null;
        resolve();
      }
    }
    
    type();
  });
}

async function showMystereepleDialogue() {
  const dialogue = document.getElementById('mystereeple-dialogue');
  const textElement = document.getElementById('mystereeple-text');
  const buttons = document.getElementById('mystereeple-buttons');
  
  // If typing is in progress, cancel it and restart
  if (typingInProgress) {
    typingInProgress = false;
    if (currentTypingTimeout) {
      clearTimeout(currentTypingTimeout);
      currentTypingTimeout = null;
    }
  }
  
  dialogue.classList.add('visible');
  buttons.classList.remove('visible');
  
  // Check if user is out
  <% if @user_is_out %>
    try {
      await typeText(textElement, "Sorry, but I cannot talk to you if you aren't still in the siege...");
      setTimeout(() => {
        closeMystereepleDialogue();
      }, 3000);
    } catch (e) {
      // Typing was cancelled, do nothing
    }
    return;
  <% end %>
  
  // Check if mystereeple is visible (any windows available)
  <% if !@mystereeple_visible %>
    try {
      await typeText(textElement, "Check back here later, I'll have something for you in a couple days :)");
      setTimeout(() => {
        closeMystereepleDialogue();
      }, 3000);
    } catch (e) {
      // Typing was cancelled, do nothing
    }
    return;
  <% end %>
  
  // Reset and show initial dialogue
  currentWindowIndex = 0;
  buttons.innerHTML = '';
  
  try {
    await typeText(textElement, "What are you looking for?");
    
    // Build buttons dynamically
    if (availableWindows.length > 0) {
      const firstWindow = availableWindows[0];
      const buttonText = getWindowButtonText(firstWindow.type);
      
      const btn1 = document.createElement('button');
      btn1.className = 'mystereeple-dialogue-button';
      btn1.textContent = buttonText;
      btn1.onclick = () => handleWindowAction(firstWindow.type);
      buttons.appendChild(btn1);
      
      const btn2 = document.createElement('button');
      btn2.className = 'mystereeple-dialogue-button';
      btn2.textContent = 'Do you have anything else?';
      btn2.onclick = handleAnythingElse;
      buttons.appendChild(btn2);
    }
    
    buttons.classList.add('visible');
  } catch (e) {
    // Typing was cancelled, do nothing
  }
}

function getWindowButtonText(windowType) {
  switch(windowType) {
    case 'betting': return 'Place a bet';
    case 'shop': return 'See the items';
    default: return 'View';
  }
}

function getWindowQuestion(windowType) {
  switch(windowType) {
    case 'betting': return 'Would you like to place a bet?';
    case 'shop': return 'Would you like some items?';
    default: return 'Interested?';
  }
}

function handleWindowAction(windowType) {
  switch(windowType) {
    case 'betting':
      handlePlaceBet();
      break;
    case 'shop':
      handleSeeItems();
      break;
  }
}

function closeMystereepleDialogue() {
  typingInProgress = false;
  document.getElementById('mystereeple-dialogue').classList.remove('visible');
  document.getElementById('mystereeple-buttons').classList.remove('visible');
}

let selectedBetHours = null;
let selectedBetMultiplier = null;
let betAmount = 25;
let globalBetAmount = 25;
let hoursPrediction = 1000;
let lastWeekHours = 0;
let globalMultiplier = 1.5;
let bettingMode = 'personal'; // 'personal' or 'global'
let userCoins = 0;
let hasPersonalBet = <%= @personal_bet ? 'true' : 'false' %>;
let hasGlobalBet = <%= @global_bet ? 'true' : 'false' %>;
let bettingEnabled = <%= @betting_enabled ? 'true' : 'false' %>;
let isBettingDay = <%= @is_betting_day ? 'true' : 'false' %>;
let availableWindows = <%= @available_windows.map { |w| { type: w.window_type, name: w.name } }.to_json.html_safe %>;
let currentWindowIndex = 0;

async function loadUserCoins() {
  try {
    const response = await fetch('/market/user_coins', {
      headers: {
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    });
    const data = await response.json();
    userCoins = data.coins || 0;
    document.getElementById('user-coins-display').textContent = userCoins;
    updateBetButtonState();
  } catch (error) {
    console.error('Failed to load user coins:', error);
    userCoins = 0;
  }
}

async function handlePlaceBet() {
  closeMystereepleDialogue();
  document.getElementById('betting-interface').classList.add('visible');
  
  // Load user coins
  await loadUserCoins();
  
  // Fetch last week's hours if not already loaded
  if (lastWeekHours === 0 && bettingMode === 'global') {
    await fetchLastWeekHours();
  }
}

async function fetchLastWeekHours() {
  try {
    const response = await fetch('/catacombs/last_week_hours');
    const data = await response.json();
    lastWeekHours = data.hours;
    document.getElementById('last-week-hours').textContent = lastWeekHours;
    updateGlobalMultiplier();
  } catch (error) {
    console.error('Error fetching last week hours:', error);
    document.getElementById('last-week-hours').textContent = 'Error';
  }
}

function closeBettingInterface() {
  document.getElementById('betting-interface').classList.remove('visible');
  // Reset selection
  document.querySelectorAll('.bet-panel').forEach(panel => {
    panel.classList.remove('selected');
  });
  selectedBetHours = null;
  selectedBetMultiplier = null;
  document.getElementById('submit-bet-button').disabled = true;
}

function selectBetPanel(panel) {
  // Remove selection from all panels
  document.querySelectorAll('.bet-panel').forEach(p => {
    p.classList.remove('selected');
  });
  
  // Select this panel
  panel.classList.add('selected');
  selectedBetHours = parseInt(panel.dataset.hours);
  selectedBetMultiplier = parseFloat(panel.dataset.multiplier);
  
  // Enable submit button
  document.getElementById('submit-bet-button').disabled = false;
  
  // Update payout
  updatePersonalPayout();
}

function updateBetAmount(value) {
  betAmount = parseInt(value);
  document.getElementById('bet-amount-display').textContent = betAmount;
  updatePersonalPayout();
}

function updatePersonalPayout() {
  if (selectedBetMultiplier) {
    const payout = Math.floor(betAmount * selectedBetMultiplier);
    document.getElementById('personal-payout-display').textContent = payout;
  }
  updateBetButtonState();
}

function updateBetButtonState() {
  const personalButton = document.getElementById('submit-bet-button');
  const globalButton = document.getElementById('submit-global-bet-button');
  
  if (bettingMode === 'personal') {
    personalButton.disabled = !selectedBetHours || betAmount > userCoins;
  } else {
    globalButton.disabled = globalBetAmount > userCoins;
  }
}

async function submitBet() {
  if (!selectedBetHours || !selectedBetMultiplier) {
    showModalAlert('Please select a bet option first!', 'Error');
    return;
  }
  
  if (betAmount > userCoins) {
    showModalAlert('Not enough coins!', 'Error');
    return;
  }
  
  try {
    const response = await fetch('/catacombs/place_personal_bet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({
        coin_amount: betAmount,
        hours_goal: selectedBetHours,
        multiplier: selectedBetMultiplier
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      userCoins = data.remaining_coins;
      document.getElementById('user-coins-display').textContent = userCoins;
      
      // Update title and state
      hasPersonalBet = true;
      document.getElementById('betting-title').textContent = 'Your personal bet';
      
      // Fetch current progress
      fetch('/catacombs/current_progress', {
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      })
      .then(res => res.json())
      .then(progress => {
        const currentHours = progress.personal_hours;
        const payout = Math.floor(betAmount * selectedBetMultiplier);
        const progressPercent = Math.min((currentHours / selectedBetHours * 100), 100);
        
        // Switch to bet status view
        const personalContent = document.getElementById('personal-betting-content');
        
        personalContent.innerHTML = `
          <div class="bet-info">
            <div class="global-stat">Goal: <span class="global-stat-value">${escapeHtml(String(selectedBetHours))}h</span></div>
            <div class="global-stat">Coins bet: <span class="global-stat-value">${escapeHtml(String(betAmount))}</span></div>
            <div class="global-payout">Estimated payout: <span class="global-payout-value">${escapeHtml(String(payout))}</span> coins</div>
            
            <div class="bet-progress">
              <div class="bet-progress-label">Your progress:</div>
              <div class="bet-progress-bar">
                <div class="bet-progress-fill" style="width: ${escapeHtml(String(progressPercent))}%"></div>
              </div>
              <div class="bet-progress-text">${escapeHtml(String(currentHours))}h / ${escapeHtml(String(selectedBetHours))}h</div>
            </div>
            
            <div class="betting-actions">
              ${currentHours >= selectedBetHours ? `<button class="betting-button" id="collect-personal-bet-btn" onclick="collectPersonalBet()">Collect Bet</button>` : ''}
              <button class="betting-button" onclick="closeBettingInterface()">Close</button>
            </div>
          </div>
        `;
      });
    } else {
      showModalAlert(data.message, 'Error');
    }
  } catch (error) {
    console.error('Error placing bet:', error);
    showModalAlert('Failed to place bet. Please try again.', 'Error');
  }
}

function toggleBettingMode() {
  const toggle = document.getElementById('betting-mode-toggle');
  const title = document.getElementById('betting-title');
  const personalContent = document.getElementById('personal-betting-content');
  const globalContent = document.getElementById('global-betting-content');
  
  if (bettingMode === 'personal') {
    bettingMode = 'global';
    toggle.textContent = 'Personal';
    title.textContent = hasGlobalBet ? 'Your global bet' : 'Place a global bet';
    personalContent.classList.add('hidden');
    globalContent.classList.add('visible');
    
    // Fetch last week's hours if not already loaded
    if (lastWeekHours === 0) {
      fetchLastWeekHours();
    }
  } else {
    bettingMode = 'personal';
    toggle.textContent = 'Global';
    title.textContent = hasPersonalBet ? 'Your personal bet' : 'Place a personal bet';
    personalContent.classList.remove('hidden');
    globalContent.classList.remove('visible');
  }
}

function updateHoursPrediction(value) {
  hoursPrediction = parseInt(value);
  document.getElementById('hours-prediction-display').textContent = hoursPrediction;
  updateGlobalMultiplier();
}

function updateGlobalMultiplier() {
  if (lastWeekHours === 0) {
    globalMultiplier = 1.5;
  } else {
    const percentage = hoursPrediction / lastWeekHours;
    
    // Piecewise quadratic formula for smooth curves:
    // 0.8 → 1.0x, 1.0 → 2.0x, 1.05 → 2.5x
    if (percentage < 0.8) {
      globalMultiplier = 1.0;
    } else if (percentage < 1.0) {
      // Quadratic curve from 0.8 to 1.0
      const t = (percentage - 0.8) / 0.2; // normalize to 0-1
      globalMultiplier = 1.0 + 1.0 * (t * t);
    } else if (percentage < 1.05) {
      // Quadratic curve from 1.0 to 1.05
      const t = (percentage - 1.0) / 0.05; // normalize to 0-1
      globalMultiplier = 2.0 + 0.5 * (t * t);
    } else {
      // Continue quadratic growth above 1.05
      globalMultiplier = 2.5 + 0.5 * Math.pow((percentage - 1.05) / 0.05, 2);
    }
  }
  
  document.getElementById('global-multiplier-display').textContent = globalMultiplier.toFixed(2) + 'x';
  updateGlobalPayout();
}

function updateGlobalBetAmount(value) {
  globalBetAmount = parseInt(value);
  document.getElementById('global-bet-amount-display').textContent = globalBetAmount;
  updateGlobalPayout();
  updateBetButtonState();
}

function updateGlobalPayout() {
  const payout = Math.floor(globalBetAmount * globalMultiplier);
  document.getElementById('global-payout-display').textContent = payout;
}

async function submitGlobalBet() {
  if (globalBetAmount > userCoins) {
    showModalAlert('Not enough coins!', 'Error');
    return;
  }
  
  try {
    const response = await fetch('/catacombs/place_global_bet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({
        coin_amount: globalBetAmount,
        predicted_hours: hoursPrediction,
        multiplier: globalMultiplier
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      userCoins = data.remaining_coins;
      document.getElementById('user-coins-display').textContent = userCoins;
      
      // Update title and state
      hasGlobalBet = true;
      document.getElementById('betting-title').textContent = 'Your global bet';
      
      // Fetch current progress
      fetch('/catacombs/current_progress', {
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      })
      .then(res => res.json())
      .then(progress => {
        const currentHours = progress.global_hours;
        const payout = Math.floor(globalBetAmount * globalMultiplier);
        const progressPercent = Math.min((currentHours / hoursPrediction * 100), 100);
        
        // Switch to bet status view
        const globalContent = document.getElementById('global-betting-content');
        
        globalContent.innerHTML = `
          <div class="bet-info">
            <div class="global-stat">Your prediction: <span class="global-stat-value">${escapeHtml(String(hoursPrediction))}h</span></div>
            <div class="global-stat">Coins bet: <span class="global-stat-value">${escapeHtml(String(globalBetAmount))}</span></div>
            <div class="global-payout">Estimated payout: <span class="global-payout-value">${escapeHtml(String(payout))}</span> coins</div>
            
            <div class="bet-progress">
              <div class="bet-progress-label">Global progress:</div>
              <div class="bet-progress-bar">
                <div class="bet-progress-fill" style="width: ${escapeHtml(String(progressPercent))}%"></div>
              </div>
              <div class="bet-progress-text">${escapeHtml(String(currentHours))}h / ${escapeHtml(String(hoursPrediction))}h</div>
            </div>
            
            <div class="betting-actions">
              ${currentHours >= hoursPrediction ? `<button class="betting-button" id="collect-global-bet-btn" onclick="collectGlobalBet()">Collect Bet</button>` : ''}
              <button class="betting-button" onclick="closeBettingInterface()">Close</button>
            </div>
          </div>
        `;
      });
    } else {
      showModalAlert(data.message, 'Error');
    }
  } catch (error) {
    console.error('Error placing global bet:', error);
    showModalAlert('Failed to place bet. Please try again.', 'Error');
  }
}

async function collectPersonalBet() {
  try {
    const response = await fetch('/catacombs/collect_personal_bet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    });
    
    const data = await response.json();
    
    if (data.success) {
      userCoins = data.new_balance;
      document.getElementById('user-coins-display').textContent = userCoins;
      document.getElementById('collect-personal-bet-btn').disabled = true;
      document.getElementById('collect-personal-bet-btn').textContent = 'Collected';
    } else {
      showModalAlert(data.message, 'Error');
    }
  } catch (error) {
    console.error('Error collecting bet:', error);
    showModalAlert('Failed to collect bet. Please try again.', 'Error');
  }
}

async function collectGlobalBet() {
  try {
    const response = await fetch('/catacombs/collect_global_bet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    });
    
    const data = await response.json();
    
    if (data.success) {
      userCoins = data.new_balance;
      document.getElementById('user-coins-display').textContent = userCoins;
      document.getElementById('collect-global-bet-btn').disabled = true;
      document.getElementById('collect-global-bet-btn').textContent = 'Collected';
    } else {
      showModalAlert(data.message, 'Error');
    }
  } catch (error) {
    console.error('Error collecting bet:', error);
    showModalAlert('Failed to collect bet. Please try again.', 'Error');
  }
}

async function handleSeeItems() {
  closeMystereepleDialogue();
  document.getElementById('shop-interface').classList.add('visible');
  loadShopItems();
}

async function handleAnythingElse() {
  currentWindowIndex++;
  
  const textElement = document.getElementById('mystereeple-text');
  const buttons = document.getElementById('mystereeple-buttons');
  
  buttons.innerHTML = '';
  buttons.classList.remove('visible');
  
  // If there are more windows to show
  if (currentWindowIndex < availableWindows.length) {
    const window = availableWindows[currentWindowIndex];
    const question = getWindowQuestion(window.type);
    
    try {
      await typeText(textElement, question);
      
      // Build buttons
      const btn1 = document.createElement('button');
      btn1.className = 'mystereeple-dialogue-button';
      btn1.textContent = 'Yes';
      btn1.onclick = () => handleWindowAction(window.type);
      buttons.appendChild(btn1);
      
      const btn2 = document.createElement('button');
      btn2.className = 'mystereeple-dialogue-button';
      btn2.textContent = 'Do you have anything else?';
      btn2.onclick = handleAnythingElse;
      buttons.appendChild(btn2);
      
      buttons.classList.add('visible');
    } catch (e) {
      // Typing was cancelled
    }
  } else {
    // No more windows, show wall message
    try {
      await typeText(textElement, "The only other thing is this wall behind me... I wonder what's behind it...");
      setTimeout(() => {
        closeMystereepleDialogue();
      }, 3000);
    } catch (e) {
      // Typing was cancelled
    }
  }
}


// Register Catacombs Manager
(function() {
  const catacombsElement = document.querySelector('.catacombs');
  if (!catacombsElement) return; // Not on catacombs page

  class CatacombsManager {
    constructor() {
      this.originalWidth = 3392;
      this.originalHeight = 2358;
      this.glyphConfig = {
        x: 1560,
        y: 1100,
        fontSize: 50
      };
    }

    initialize() {
      console.log('Catacombs: Initializing...');
      
      try {
        this.setupClickSystem();
        this.setupGlyphDisplay();
        
        this.isValid = true;
        return true;
      } catch (error) {
        console.error('Catacombs: Initialization failed:', error);
        return false;
      }
    }

    validate() {
      return this.isValid && 
             document.querySelector('.catacombs') &&
             document.querySelector('.hover-overlay');
    }

    setupClickSystem() {
      const hoverOverlay = document.querySelector('.hover-overlay');
      if (!hoverOverlay) return;
      
      hoverOverlay.innerHTML = ''; // Clear existing
      
      this.createHoverSVG();
      this.updateHoverSVGPosition();
      
      window.addEventListener('resize', () => {
        this.updateHoverSVGPosition();
        this.updateGlyphPosition();
      });
    }

    setupGlyphDisplay() {
      this.updateGlyphPosition();
    }

    updateGlyphPosition() {
      const glyphDisplay = document.getElementById('glyph-display');
      if (!glyphDisplay) return;
      
      const scaleX = window.innerWidth / this.originalWidth;
      const scaleY = window.innerHeight / this.originalHeight;
      const baseScale = Math.max(scaleX, scaleY);
      
      const scaledWidth = this.originalWidth * baseScale;
      const scaledHeight = this.originalHeight * baseScale;
      
      const catacombsOffsetX = (window.innerWidth - scaledWidth) / 2;
      const catacombsOffsetY = (window.innerHeight - scaledHeight) / 2;
      
      const scaledGlyphX = (this.glyphConfig.x * baseScale) + catacombsOffsetX;
      const scaledGlyphY = (this.glyphConfig.y * baseScale) + catacombsOffsetY;
      const scaledFontSize = this.glyphConfig.fontSize * baseScale;
      
      glyphDisplay.style.left = scaledGlyphX + 'px';
      glyphDisplay.style.top = scaledGlyphY + 'px';
      glyphDisplay.style.fontSize = scaledFontSize + 'px';
      glyphDisplay.style.transform = 'rotate(3deg)';
      glyphDisplay.style.transformOrigin = 'left top';
    }

    createHoverSVG() {
      const hoverOverlay = document.querySelector('.hover-overlay');
      const svgElement = document.createElement('div');
      svgElement.className = 'hover-box';
      
      const clickAreas = [];
      
      // Only add mystereeple click area if visible
      const mystereepleVisible = <%= @mystereeple_visible ? 'true' : 'false' %>;
      if (mystereepleVisible) {
        clickAreas.push({
          id: 'mystereeple',
          path: `M177 754H109L91 687.5L148.5 516.5L68.5 499L1 466L17.5 426.5L68.5 368.5L152 321L148.5 265.5L160.5 252V205.5L176 158.5L112.5 131.5L100.5 112.5L124.5 87L198 82L234.5 1L338.5 19.5L347.5 40L363.5 19.5L470 32L474 121.5L539.5 150.5V180.5L516 193.5L451 205.5L459 269L430.5 321L486 351L539.5 404L559 438L550 473.5L525 486L436 512.5L413.5 648.5L418.5 717.5L360 773.5L293 712L221 704L177 754Z`,
          fill: "#E40000",
          fillOpacity: "0",
          stroke: "",
          x: 2050,
          y: 1360,
          scale: 1,
          targetLayer: 'mystereeple',
          action: 'showMystereepleDialogue'
        });
      }
      
      let svgContent = `<svg width="100%" height="100%" viewBox="0 0 ${this.originalWidth} ${this.originalHeight}" xmlns="http://www.w3.org/2000/svg">`;
      
      clickAreas.forEach(area => {
        if (!area.path) return; // Skip empty paths
        
        let transform = '';
        if (area.x !== 0 || area.y !== 0) {
          transform += `translate(${area.x}, ${area.y}) `;
        }
        if (area.scale !== 1.0) {
          transform += `scale(${area.scale}) `;
        }
        
        svgContent += `<path id="${area.id}" d="${area.path}" fill="${area.fill}" fill-opacity="${area.fillOpacity}" stroke="${area.stroke}" stroke-width="2" cursor="pointer"`;
        if (transform) {
          svgContent += ` transform="${transform.trim()}"`;
        }
        svgContent += ` />`;
      });
      
      svgContent += '</svg>';
      svgElement.innerHTML = svgContent;
      
      clickAreas.forEach(area => {
        if (!area.path) return; // Skip empty paths
        
        const pathElement = svgElement.querySelector(`#${area.id}`);
        if (pathElement) {
          const targetLayer = document.querySelector('.catacombs-layer.' + area.targetLayer);
          
          pathElement.addEventListener('mouseenter', () => {
            if (targetLayer) targetLayer.classList.add('highlighted');
            pathElement.style.opacity = '0.8';
          });
          
          pathElement.addEventListener('mouseleave', () => {
            if (targetLayer) targetLayer.classList.remove('highlighted');
            pathElement.style.opacity = '1';
          });
          
          if (area.action && window[area.action]) {
            pathElement.addEventListener('click', () => {
              window[area.action]();
            });
          }
        }
      });
      
      hoverOverlay.appendChild(svgElement);
    }

    updateHoverSVGPosition() {
      const hoverBox = document.querySelector('.hover-box');
      if (!hoverBox) return;
      
      const scaleX = window.innerWidth / this.originalWidth;
      const scaleY = window.innerHeight / this.originalHeight;
      const baseScale = Math.max(scaleX, scaleY);
      
      const scaledWidth = this.originalWidth * baseScale;
      const scaledHeight = this.originalHeight * baseScale;
      
      const catacombsOffsetX = (window.innerWidth - scaledWidth) / 2;
      const catacombsOffsetY = (window.innerHeight - scaledHeight) / 2;
      
      hoverBox.style.left = catacombsOffsetX + 'px';
      hoverBox.style.top = catacombsOffsetY + 'px';
      hoverBox.style.width = scaledWidth + 'px';
      hoverBox.style.height = scaledHeight + 'px';
    }
  }

  // Register the manager
  function registerCatacombsManager() {
    if (window.SiegeApp && typeof window.SiegeBaseManager !== 'undefined') {
      SiegeApp.registerManager('catacombs', new CatacombsManager());
    } else {
      // Wait for SiegeApp to be available
      setTimeout(registerCatacombsManager, 50);
    }
  }

  registerCatacombsManager();
})();

// Glyph input system
(function() {
  let glyphBuffer = '';
  let glyphOffsets = []; // Store offsets for each character
  let glyphDisplay = null;
  const allowedChars = /^[a-zA-Z0-9!@%&()"';:,.+\-=?]$/;
  
  function initGlyphSystem() {
    glyphDisplay = document.getElementById('glyph-display');
    if (!glyphDisplay) {
      setTimeout(initGlyphSystem, 50);
      return;
    }
    
    // Load saved runes from server
    glyphBuffer = '<%= j @current_runes || "" %>';
    
    // Initialize offsets for existing runes on page load
    for (let i = 0; i < glyphBuffer.length; i++) {
      const position = (i - 2) / 5;
      const curveOffset = -5 * (1 - 4 * position * position);
      const randomOffset = (Math.random() - 0.5) * 4;
      glyphOffsets.push(curveOffset + randomOffset);
    }
    
    // Restore runes on page load
    if (glyphBuffer.length > 0) {
      updateGlyphDisplay();
    }
  }
  
  function updateGlyphDisplay() {
    if (!glyphDisplay) return;
    
    glyphDisplay.innerHTML = '';
    
    for (let i = 0; i < glyphBuffer.length; i++) {
      const char = glyphBuffer[i];
      const span = document.createElement('span');
      span.className = 'glyph-char';
      span.textContent = char;
      
      // Use stored offset
      span.style.transform = `translateY(${glyphOffsets[i]}px)`;
      glyphDisplay.appendChild(span);
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGlyphSystem);
  } else {
    initGlyphSystem();
  }
  
  function logRunes(runes) {
    fetch('/catacombs/log_runes', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ runes: runes })
    }).catch(error => {
      console.error('Error logging runes:', error);
    });
  }
  
  document.addEventListener('keypress', function(e) {
    const char = e.key;
    
    // Only process allowed characters
    if (!allowedChars.test(char)) return;
    
    // Stop at 5 characters
    if (glyphBuffer.length >= 5) return;
    
    // Convert to uppercase
    const upperChar = char.toUpperCase();
    
    // Calculate offset for this new character
    const i = glyphBuffer.length;
    const position = (i - 2) / 5; // middle is at index 2
    const curveOffset = -5 * (1 - 4 * position * position);
    const randomOffset = (Math.random() - 0.5) * 4;
    const totalOffset = curveOffset + randomOffset;
    
    // Store offset and add to buffer
    glyphOffsets.push(totalOffset);
    glyphBuffer += upperChar;
    
    // Update display
    updateGlyphDisplay();
    
    // Log to backend on every keystroke
    logRunes(glyphBuffer);
  });
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && glyphBuffer.length > 0) {
      e.preventDefault();
      logRunes(glyphBuffer);
    }
    
    if (e.key === 'Backspace' && glyphBuffer.length > 0) {
      e.preventDefault();
      glyphBuffer = glyphBuffer.slice(0, -1);
      glyphOffsets = glyphOffsets.slice(0, -1); // Remove last offset
      updateGlyphDisplay();
      logRunes(glyphBuffer); // Save updated runes to backend
    }
  });
})();
</script>
