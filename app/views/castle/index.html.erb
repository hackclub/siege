<% content_for :body_class, "castle-page" %>

<div class="castle-container">
  <div class="castle">
    <%= image_tag "castle/0-sky.webp", class: "castle-layer" %>
		<div id="clouds"></div>
    <%= image_tag "castle/1-mountains.webp", class: "castle-layer" %>
		<div id="front-clouds"></div>
    <%= image_tag "castle/2-grass.webp", class: "castle-layer" %>
    <%= image_tag "castle/3-walls.webp", class: "castle-layer" %>
    <%= image_tag "castle/4-chambers.webp", class: "castle-layer chambers" %>
    <%= image_tag "castle/5-keep.webp", class: "castle-layer keep" %>
    <%= image_tag "castle/6-great-hall.webp", class: "castle-layer great-hall" %>
    <%= image_tag "castle/7-armory.webp", class: "castle-layer armory" %>
    <%= image_tag "castle/8-market.webp", class: "castle-layer market" %>
    <%= image_tag "castle/9-fountain.webp", class: "castle-layer" %>
    <%= image_tag "castle/10-catacombs.webp", class: "castle-layer" %>
		<%= image_tag "castle/11-foreground.webp", class: "castle-layer map" %>
		<%= image_tag "castle/12-lighting.webp", class: "castle-layer lighting" %>
	</div>
</div>
<div class="hover-overlay">
	<!-- Hover boxes will be generated by JavaScript -->
</div>

<style>
  html, body {
    overflow: hidden;
  }
  
  .castle-container {
    width: 100vw;
    background: transparent;
		overflow: hidden;
  }
  
  .castle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
		width: 100vw;
		height: 100vh;
  }
  
  .castle-layer {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    object-fit: cover;
		transition: filter 0.3s ease;		
  }

	.castle-layer:nth-child(1) { z-index: 1; }
	.castle-layer:nth-child(2) { z-index: 2; }
	.castle-layer:nth-child(3) { z-index: 3; }
	.castle-layer:nth-child(4) { z-index: 4; }
	.castle-layer:nth-child(5) { z-index: 5; }
	.castle-layer:nth-child(6) { z-index: 6; }
	.castle-layer:nth-child(7) { z-index: 7; }
	.castle-layer:nth-child(8) { z-index: 8; }
	.castle-layer:nth-child(9) { z-index: 9; }
	.castle-layer:nth-child(10) { z-index: 10; }
	.castle-layer:nth-child(11) { z-index: 11; }
	.castle-layer:nth-child(12) { z-index: 12; }
	.castle-layer:nth-child(13) { z-index: 13; }
	.castle-layer:nth-child(14) { z-index: 14; }
	.castle-layer:nth-child(15) { z-index: 15; }
	.castle-layer.lighting { mix-blend-mode: multiply; }

	#clouds, #front-clouds {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
	}
	


	#front-clouds {
		z-index: 4;
	}

	.hover-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		pointer-events: none;
		z-index: 100;
	}
	
	.hover-box {
		position: absolute;
		pointer-events: none;
		/* Position and size will be calculated by JavaScript */
	}
	
	.hover-box svg {
		width: 100%;
		height: 100%;
		pointer-events: auto;
	}
	
	.hover-box svg path,
	.hover-box svg circle,
	.hover-box svg rect,
	.hover-box svg polygon {
		cursor: pointer;
		transition: opacity 0.2s ease;
	}
	
	.hover-box svg path:hover,
	.hover-box svg circle:hover,
	.hover-box svg rect:hover,
	.hover-box svg polygon:hover {
		opacity: 0.8;
	}
	
	.castle-layer.highlighted {
		filter: drop-shadow(4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(-4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 4px 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 -4px 0 rgba(245, 231, 183, 0.8));
	}
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Castle dimensions and positioning
    const originalWidth = 2732;
    const originalHeight = 2048;
    const castle = document.querySelector('.castle');
    const hoverOverlay = document.querySelector('.hover-overlay');
    
    // Helper function to calculate path bounding box for scaling
    function getPathBounds(pathData) {
      // Simple regex to extract all numbers from path
      const numbers = pathData.match(/-?\d+\.?\d*/g);
      if (!numbers || numbers.length < 2) return { x: 0, y: 0, width: 100, height: 100 };
      
      const coords = numbers.map(n => parseFloat(n));
      let minX = coords[0], maxX = coords[0], minY = coords[1], maxY = coords[1];
      
      // Check all coordinate pairs
      for (let i = 0; i < coords.length; i += 2) {
        if (i + 1 < coords.length) {
          minX = Math.min(minX, coords[i]);
          maxX = Math.max(maxX, coords[i]);
          minY = Math.min(minY, coords[i + 1]);
          maxY = Math.max(maxY, coords[i + 1]);
        }
      }
      
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    
    // Define hover areas - all paths will be in one SVG using castle coordinates  
    const hoverAreas = [
      {
        id: 'chambers',
        path: `M1243.5 664.5V577.999C1263.5 569.999 1314.6 553.499 1359 551.499C1403.4 549.499 1462.83 560.999 1487 566.999V659L1458.5 687.5V930.5L1394.5 957L1351 930.5L1326.5 937V979.5L1344.5 996V1114L1321 1119.5L1269.5 1101V687.5L1243.5 664.5Z`,
        fill: "#E40000",
        fillOpacity: "0",
        stroke: "",
        x: -15, // X offset in castle coordinates
        y: -290, // Y offset in castle coordinates
        scale: 1.0, // Scale multiplier
        targetLayer: 'chambers',
        navigateTo: '/chambers'
      },
      {
        id: 'keep',  
        path: `M1641 884L1568 771.5L1385.5 832V723L1366.5 706.5V667L1388.5 660.5L1434.5 686.5L1498 659.5V601.5L1598.5 642L1619.5 635.5L1663.5 668.5L1672.5 649L1778.5 635.5L1887 656.5V730L1985.5 766V809L1955 819.5V916.5L1894.5 982.5L1887 1088.5L1847.5 1118.5V1145L1769.5 1166L1635 1105L1641 884Z`,
        fill: "#C72C2C", 
        fillOpacity: "0",
        stroke: "",
        x: -50, // X offset in castle coordinates
        y: -15, // Y offset in castle coordinates  
        scale: 1.0, // Scale multiplier
        targetLayer: 'keep',
        navigateTo: '/keep'
      },
			{
        id: 'great-hall',  
        path: `M97 66L290 1.5L361.5 113L355.5 332.5L180 404.5L7 324.5L13.5 124L1.5 112L97 66Z`,
        fill: "#C72C2C", 
        fillOpacity: "0",
        stroke: "",
        x: 1225, // X offset in castle coordinates
        y: 760, // Y offset in castle coordinates  
        scale: 1.0, // Scale multiplier
        targetLayer: 'great-hall',
        navigateTo: '/great-hall'
      },
			{
        id: 'armory',  
        path: `M129 300L9.5 229.5L13 140L1 129.5L60.5 79.5L226.5 1.5L322.5 100L409 104L398.5 172L359 202.5L315 172V224L294.5 262.5L262 258.5L250 234L129 300Z`,
        fill: "#C72C2C", 
        fillOpacity: "0",
        stroke: "",
        x: 525, // X offset in castle coordinates
        y: 1010, // Y offset in castle coordinates  
        scale: 1.0, // Scale multiplier
        targetLayer: 'armory',
        navigateTo: '/armory'
      },
			{
        id: 'market',  
        path: `M23 58.5L33.5 22L59.5 13.5L74.5 8.5H89L112.5 13.5L124.5 23.5L144.5 19L150.5 34L170 41.5L203.5 1L271.5 4.5V23.5L364.5 58.5L371.5 41.5L405.5 39L392 70.5L607 153L368.5 277L253 221L250.5 203H220L210.5 215.5L122 227.5L23 208L1 162L10 117L26 102.5L23 58.5Z`,
        fill: "#C72C2C", 
        fillOpacity: "0",
        stroke: "",
        x: 1250, // X offset in castle coordinates
        y: 1320, // Y offset in castle coordinates  
        scale: 1.0, // Scale multiplier
        targetLayer: 'market',
        navigateTo: '/market'
      },
			{
        id: 'map',  
        path: `M95.5 1476L1 1627.5L1033 1629L1028.5 1.5L817 50.5L856.5 263.5L837 733.5L787.5 716.5L770.5 733.5L748.5 805.5L712.5 656L660 589L597 571L528.5 589L495.5 638L489 709.5L472.5 733.5L489 788.5L555.5 805.5L548.5 835.5L510.5 844L489 900L463 912L414 999.5L445.5 1011.5L414 1054.5L388.5 1106.5L395.5 1154L368 1165L358 1145.5L359.5 1106.5L312 1094.5L260.5 1037L246.5 1039.5L215.5 1098L170 1133L128.5 1105L106 1113L95.5 1134.5V1203L77 1258L118.5 1295.5L107 1314.5L164 1350.5L118.5 1430.5L141 1451L95.5 1476Z`,
        fill: "#C72C2C", 
        fillOpacity: "0",
        stroke: "",
        x: 1700, // X offset in castle coordinates
        y: 420, // Y offset in castle coordinates  
        scale: 1.0, // Scale multiplier
        targetLayer: 'map',
        navigateTo: '/map'
      },
    ];


    // Create single SVG with all hover areas
    function createHoverSVG() {
      const svgElement = document.createElement('div');
      svgElement.className = 'hover-box';
      
      // Create master SVG using castle dimensions
      let svgContent = `<svg width="100%" height="100%" viewBox="0 0 ${originalWidth} ${originalHeight}" xmlns="http://www.w3.org/2000/svg">`;
      
      // Add each hover area as a path with transforms
      hoverAreas.forEach(area => {
        // Calculate transform string for positioning and scaling
        let transform = '';
        if (area.x !== 0 || area.y !== 0) {
          transform += `translate(${area.x}, ${area.y}) `;
        }
        if (area.scale !== 1.0) {
          // For scaling, we need to find the path's center point to scale around
          // Using a simple bounding box approach - you can make this more sophisticated
          const pathBounds = getPathBounds(area.path);
          const centerX = pathBounds.x + pathBounds.width / 2;
          const centerY = pathBounds.y + pathBounds.height / 2;
          transform += `scale(${area.scale}) translate(${-centerX * (area.scale - 1) / area.scale}, ${-centerY * (area.scale - 1) / area.scale}) `;
        }
        
        svgContent += `<path id="${area.id}" d="${area.path}" fill="${area.fill}" fill-opacity="${area.fillOpacity}" stroke="${area.stroke}" stroke-width="2" cursor="pointer"`;
        if (transform) {
          svgContent += ` transform="${transform.trim()}"`;
        }
        svgContent += ` />`;
      });
      
      svgContent += '</svg>';
      svgElement.innerHTML = svgContent;
      
      // Add event listeners to each path
      hoverAreas.forEach(area => {
        const pathElement = svgElement.querySelector(`#${area.id}`);
        if (!pathElement) return;
        
        // Add hover effect for castle layer highlighting
        if (area.targetLayer) {
          const targetLayer = document.querySelector('.castle-layer.' + area.targetLayer);
          
          pathElement.addEventListener('mouseenter', () => {
            if (targetLayer) targetLayer.classList.add('highlighted');
            pathElement.style.opacity = '0.8';
          });
          
          pathElement.addEventListener('mouseleave', () => {
            if (targetLayer) targetLayer.classList.remove('highlighted');
            pathElement.style.opacity = '1';
          });
        }
        
        // Add click navigation
        if (area.navigateTo) {
          pathElement.addEventListener('click', () => {
            window.location.href = area.navigateTo;
          });
        }
      });
      
      hoverOverlay.appendChild(svgElement);
    }
    
    // Position the hover SVG to match the castle
    function updateHoverSVGPosition() {
      const hoverBox = document.querySelector('.hover-box');
      if (!hoverBox) return;
      
      // Calculate scale factors for object-fit: cover
      const scaleX = window.innerWidth / originalWidth;
      const scaleY = window.innerHeight / originalHeight;
      const baseScale = Math.max(scaleX, scaleY);
      
      // Calculate scaled castle dimensions
      const scaledWidth = originalWidth * baseScale;
      const scaledHeight = originalHeight * baseScale;
      
      // Calculate position to match castle positioning
      const castleOffsetX = (window.innerWidth - scaledWidth) / 2;
      const castleOffsetY = (window.innerHeight - scaledHeight) / 2;
      
      // Position and size the SVG to exactly match the castle
      hoverBox.style.left = castleOffsetX + 'px';
      hoverBox.style.top = castleOffsetY + 'px';
      hoverBox.style.width = scaledWidth + 'px';
      hoverBox.style.height = scaledHeight + 'px';
    }
    
    // Initialize hover SVG
    createHoverSVG();
    updateHoverSVGPosition();
    
    // Update on window resize
    window.addEventListener('resize', updateHoverSVGPosition);
    
    // Cloud animation system - using Rails asset paths
    const clouds = document.getElementById('clouds');
    const frontClouds = document.getElementById('front-clouds');
    const cloudImages = [
      '<%= asset_path("castle/cloud-1.webp") %>',
      '<%= asset_path("castle/cloud-2.webp") %>',
      '<%= asset_path("castle/cloud-3.webp") %>',
      '<%= asset_path("castle/cloud-4.webp") %>'
    ];
    
    function createCloud(isInitial) {
      const cloud = document.createElement('img');
      const randomCloud = cloudImages[Math.floor(Math.random() * cloudImages.length)];
      cloud.src = randomCloud;
      cloud.className = 'floating-cloud';
      
      // Random properties for depth effect
      const scale = Math.random() * 2; // 0.3 to 1.1
      const opacity = Math.max(0.3, scale / 3); // Farther clouds are more transparent
      const speed = (2.5 - scale) * 130; // Farther clouds move slower (1-3 seconds per 100vw)
      const topPosition = Math.random() * 20 - 8; // Random height in top 40% of screen
      
      let startLeft, animationDuration, adjustedTopPosition;
      
      if (isInitial) {
        // Generate random progress through the animation (0 = start, 1 = end)
        const progress = Math.max(0, Math.min(Math.random() / 10 * isInitial + 0.3, 1));
				console.log(progress);
        
        // Calculate position based on progress (70vw to -400px total journey)
        const startPosVw = 70;
        const endPosPx = -400;
        const endPosVw = (endPosPx / window.innerWidth) * 100; // Convert -400px to vw
        const totalDistance = startPosVw - endPosVw; // Total distance in vw
        startLeft = startPosVw - (progress * totalDistance);
        
        // Calculate remaining animation duration based on remaining progress
        animationDuration = speed * (1 - progress);
        
        // Adjust Y position based on progress - clouds drift slightly downward as they travel
        const verticalDrift = progress * 20; // Up to 5vh drift
        adjustedTopPosition = topPosition + verticalDrift;
      } else {
        // Normal clouds start from the right
        startLeft = 70;
        animationDuration = speed;
        adjustedTopPosition = topPosition;
      }
            
      cloud.style.cssText = `
        position: absolute;
        left: ${startLeft}vw;
        top: ${adjustedTopPosition - 20}vh;
        width: ${scale * 200}px;
        height: auto;
        opacity: ${opacity};
        pointer-events: none;
				rotate: -10deg;
        transition: all ${animationDuration}s linear;
      `;
      
			if (scale > 1 && topPosition < 10) {
				frontClouds.appendChild(cloud);
			} else {
				clouds.appendChild(cloud);
			}
      
      // Start animation
      setTimeout(() => {
        cloud.style.left = `-400px`;
				cloud.style.top = `${topPosition}vh`;
      }, 100);
      
      // Remove cloud after animation
      setTimeout(() => {
        if (cloud.parentNode) {
          cloud.parentNode.removeChild(cloud);
        }
      }, animationDuration * 1000 + 500);
    }
    
    // Spawn clouds randomly
    function scheduleNextCloud() {
      const delay = Math.random() * 2000 + 5000; // 3-11 seconds
      setTimeout(() => {
        createCloud();
        scheduleNextCloud();
      }, delay);
    }
    
    // Start cloud system with initial clouds
    const initialCloudCount = Math.floor(Math.random() * 2) + 7; // 4-8 clouds
    for (let i = 0; i < initialCloudCount; i++) {
      // Stagger initial clouds across the screen
      createCloud(i); // Pass true for initial clouds
    }
    
    scheduleNextCloud();
  });
</script>