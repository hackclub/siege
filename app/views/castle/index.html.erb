<% content_for :body_class, "castle-page" %>

<div class="castle-container">
  <div class="castle">
    <%= image_tag "castle/0-sky.webp", class: "castle-layer" %>
		<div id="clouds"></div>
    <%= image_tag "castle/1-mountains.webp", class: "castle-layer" %>
		<div id="front-clouds"></div>
    <%= image_tag "castle/2-grass.webp", class: "castle-layer" %>
    <%= image_tag "castle/3-walls.webp", class: "castle-layer" %>
    <%= image_tag "castle/4-chambers.webp", class: "castle-layer chambers" %>
    <%= image_tag "castle/5-keep.webp", class: "castle-layer keep" %>
    <%= image_tag "castle/6-great-hall.webp", class: "castle-layer great-hall" %>
    <%= image_tag "castle/7-armory.webp", class: "castle-layer armory" %>
    <%= image_tag "castle/8-market.webp", class: "castle-layer market" %>
    <%= image_tag "castle/9-fountain.webp", class: "castle-layer" %>
    <%= image_tag "castle/10-catacombs.webp", class: "castle-layer" %>
		<%= image_tag "castle/11-foreground.webp", class: "castle-layer map" %>
		<%= image_tag "castle/12-lighting.webp", class: "castle-layer lighting" %>
	</div>
</div>
<div class="hover-overlay">
	<!-- Hover boxes will be generated by JavaScript -->
</div>

<div class="castle-logo-display">
	<div class="castle-logo-container">
		<%= image_tag "logo.webp", alt: "Siege Logo", class: "siege-logo" %>
	</div>
</div>

<style>
  html, body {
    overflow: hidden;
  }
  
  .castle-container {
    width: 100vw;
    background: transparent;
		overflow: hidden;
  }
  
  .castle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
		width: 100vw;
		height: 100vh;
  }
  
  .castle-layer {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    object-fit: cover;
		transition: filter 0.3s ease;		
  }

	.castle-layer:nth-child(1) { z-index: 1; }
	.castle-layer:nth-child(2) { z-index: 2; }
	.castle-layer:nth-child(3) { z-index: 3; }
	.castle-layer:nth-child(4) { z-index: 4; }
	.castle-layer:nth-child(5) { z-index: 5; }
	.castle-layer:nth-child(6) { z-index: 6; }
	.castle-layer:nth-child(7) { z-index: 7; }
	.castle-layer:nth-child(8) { z-index: 8; }
	.castle-layer:nth-child(9) { z-index: 9; }
	.castle-layer:nth-child(10) { z-index: 10; }
	.castle-layer:nth-child(11) { z-index: 11; }
	.castle-layer:nth-child(12) { z-index: 12; }
	.castle-layer:nth-child(13) { z-index: 13; }
	.castle-layer:nth-child(14) { z-index: 14; }
	.castle-layer:nth-child(15) { z-index: 15; }
	.castle-layer.lighting { mix-blend-mode: multiply; }

	#clouds, #front-clouds {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
	}
	


	#front-clouds {
		z-index: 4;
	}

	.hover-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		pointer-events: none;
		z-index: 100;
	}
	
	.hover-box {
		position: absolute;
		pointer-events: none;
		/* Position and size will be calculated by JavaScript */
	}
	
	.hover-box svg {
		width: 100%;
		height: 100%;
		pointer-events: auto;
	}
	
	.hover-box svg path,
	.hover-box svg circle,
	.hover-box svg rect,
	.hover-box svg polygon {
		cursor: pointer;
		transition: opacity 0.2s ease;
	}
	
	.hover-box svg path:hover,
	.hover-box svg circle:hover,
	.hover-box svg rect:hover,
	.hover-box svg polygon:hover {
		opacity: 0.8;
	}
	
	.castle-layer.highlighted {
		filter: drop-shadow(4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(-4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 4px 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 -4px 0 rgba(245, 231, 183, 0.8));
	}

	.castle-logo-display {
		position: fixed;
		display: flex;
		flex-direction: column;
		align-items: center;
		z-index: 200;
		pointer-events: none;
	}

	.castle-logo-container {
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.siege-logo {
		width: 100%;
		height: 100%;
		object-fit: contain;
	}
</style>

<script>
  // Castle page initialization handled by CastleManager
    
  // Register Castle Manager
  function initializeCastle() {
    console.log('Castle script starting...');
    
    const castleElement = document.querySelector('.castle');
    if (!castleElement) {
      console.log('Castle element not found!');
      return; // Not on castle page
    }
    
    console.log('Castle element found:', castleElement);

    class CastleManager {
    constructor() {
    this.originalWidth = 2732;
    this.originalHeight = 2048;
    this.cloudImages = [
    '<%= asset_path("castle/cloud-1.webp") %>',
    '<%= asset_path("castle/cloud-2.webp") %>',
    '<%= asset_path("castle/cloud-3.webp") %>',
    '<%= asset_path("castle/cloud-4.webp") %>'
    ];
      this.logoConfig = {
            x: 55,
            y: 50,
            width: 120,
            height: 60,
            scale: 6
          };
        }

      initialize() {
        console.log('Castle: Initializing...');
        
        try {
          this.setupHoverSystem();
          this.setupCloudSystem();
          this.setupLogoSystem();
          
          this.isValid = true;
          return true;
        } catch (error) {
          console.error('Castle: Initialization failed:', error);
          return false;
        }
      }

      validate() {
        return this.isValid && 
               document.querySelector('.castle') &&
               document.querySelector('.hover-overlay');
      }

      setupHoverSystem() {
        const hoverOverlay = document.querySelector('.hover-overlay');
        if (!hoverOverlay) return;
        
        hoverOverlay.innerHTML = ''; // Clear existing
        
        this.createHoverSVG();
        this.updateHoverSVGPosition();
        
        window.addEventListener('resize', () => {
          this.updateHoverSVGPosition();
        });
      }

      setupCloudSystem() {
        const clouds = document.getElementById('clouds');
        const frontClouds = document.getElementById('front-clouds');
        
        if (!clouds || !frontClouds) return;
        
        // Create initial clouds
        const initialCloudCount = Math.floor(Math.random() * 2) + 7;
        for (let i = 0; i < initialCloudCount; i++) {
          this.createCloud(true, clouds, frontClouds, i);
        }
        
        this.scheduleNextCloud();
      }

      setupLogoSystem() {
        this.updateLogoPosition();
        
        window.addEventListener('resize', () => {
          this.updateLogoPosition();
        });
      }

      updateLogoPosition() {
        const logoDisplay = document.querySelector('.castle-logo-display');
        const logoContainer = document.querySelector('.castle-logo-container');
        if (!logoDisplay || !logoContainer) return;
        
        const scaleX = window.innerWidth / this.originalWidth;
        const scaleY = window.innerHeight / this.originalHeight;
        const baseScale = Math.max(scaleX, scaleY);
        
        const scaledWidth = this.originalWidth * baseScale;
        const scaledHeight = this.originalHeight * baseScale;
        
        const castleOffsetX = (window.innerWidth - scaledWidth) / 2;
        const castleOffsetY = (window.innerHeight - scaledHeight) / 2;
        
        const scaledLogoX = (this.logoConfig.x * baseScale * this.logoConfig.scale) + castleOffsetX;
        const scaledLogoY = (this.logoConfig.y * baseScale * this.logoConfig.scale) + castleOffsetY;
        const scaledLogoWidth = this.logoConfig.width * baseScale * this.logoConfig.scale;
        const scaledLogoHeight = this.logoConfig.height * baseScale * this.logoConfig.scale;
        
        logoDisplay.style.left = scaledLogoX + 'px';
        logoDisplay.style.top = scaledLogoY + 'px';
        
        logoContainer.style.width = scaledLogoWidth + 'px';
        logoContainer.style.height = scaledLogoHeight + 'px';
      }

      createHoverSVG() {
        const hoverOverlay = document.querySelector('.hover-overlay');
        const svgElement = document.createElement('div');
        svgElement.className = 'hover-box';
        
        const hoverAreas = [
          {
            id: 'chambers',
            path: `M1243.5 664.5V577.999C1263.5 569.999 1314.6 553.499 1359 551.499C1403.4 549.499 1462.83 560.999 1487 566.999V659L1458.5 687.5V930.5L1394.5 957L1351 930.5L1326.5 937V979.5L1344.5 996V1114L1321 1119.5L1269.5 1101V687.5L1243.5 664.5Z`,
            fill: "#E40000",
            fillOpacity: "0",
            stroke: "",
            x: -15,
            y: -290,
            scale: 1.0,
            targetLayer: 'chambers',
            navigateTo: '/chambers'
          },
          {
            id: 'keep',  
            path: `M1641 884L1568 771.5L1385.5 832V723L1366.5 706.5V667L1388.5 660.5L1434.5 686.5L1498 659.5V601.5L1598.5 642L1619.5 635.5L1663.5 668.5L1672.5 649L1778.5 635.5L1887 656.5V730L1985.5 766V809L1955 819.5V916.5L1894.5 982.5L1887 1088.5L1847.5 1118.5V1145L1769.5 1166L1635 1105L1641 884Z`,
            fill: "#C72C2C", 
            fillOpacity: "0",
            stroke: "",
            x: -50,
            y: -15,
            scale: 1.0,
            targetLayer: 'keep',
            navigateTo: '/keep'
          },
          {
            id: 'great-hall',  
            path: `M97 66L290 1.5L361.5 113L355.5 332.5L180 404.5L7 324.5L13.5 124L1.5 112L97 66Z`,
            fill: "#C72C2C", 
            fillOpacity: "0",
            stroke: "",
            x: 1225,
            y: 760,
            scale: 1.0,
            targetLayer: 'great-hall',
            navigateTo: '/great-hall'
          },
          {
            id: 'armory',  
            path: `M129 300L9.5 229.5L13 140L1 129.5L60.5 79.5L226.5 1.5L322.5 100L409 104L398.5 172L359 202.5L315 172V224L294.5 262.5L262 258.5L250 234L129 300Z`,
            fill: "#C72C2C", 
            fillOpacity: "0",
            stroke: "",
            x: 525,
            y: 1010,
            scale: 1.0,
            targetLayer: 'armory',
            navigateTo: '/armory'
          },
          {
            id: 'market',  
            path: `M23 58.5L33.5 22L59.5 13.5L74.5 8.5H89L112.5 13.5L124.5 23.5L144.5 19L150.5 34L170 41.5L203.5 1L271.5 4.5V23.5L364.5 58.5L371.5 41.5L405.5 39L392 70.5L607 153L368.5 277L253 221L250.5 203H220L210.5 215.5L122 227.5L23 208L1 162L10 117L26 102.5L23 58.5Z`,
            fill: "#C72C2C", 
            fillOpacity: "0",
            stroke: "",
            x: 1250,
            y: 1320,
            scale: 1.0,
            targetLayer: 'market',
            navigateTo: '/market'
          },
          {
            id: 'map',  
            path: `M95.5 1476L1 1627.5L1033 1629L1028.5 1.5L817 50.5L856.5 263.5L837 733.5L787.5 716.5L770.5 733.5L748.5 805.5L712.5 656L660 589L597 571L528.5 589L495.5 638L489 709.5L472.5 733.5L489 788.5L555.5 805.5L548.5 835.5L510.5 844L489 900L463 912L414 999.5L445.5 1011.5L414 1054.5L388.5 1106.5L395.5 1154L368 1165L358 1145.5L359.5 1106.5L312 1094.5L260.5 1037L246.5 1039.5L215.5 1098L170 1133L128.5 1105L106 1113L95.5 1134.5V1203L77 1258L118.5 1295.5L107 1314.5L164 1350.5L118.5 1430.5L141 1451L95.5 1476Z`,
            fill: "#C72C2C", 
            fillOpacity: "0",
            stroke: "",
            x: 1700,
            y: 420,
            scale: 1.0,
            targetLayer: 'map',
            navigateTo: '/map'
          }
        ];
        
        let svgContent = `<svg width="100%" height="100%" viewBox="0 0 ${this.originalWidth} ${this.originalHeight}" xmlns="http://www.w3.org/2000/svg">`;
        
        hoverAreas.forEach(area => {
          let transform = '';
          if (area.x !== 0 || area.y !== 0) {
            transform += `translate(${area.x}, ${area.y}) `;
          }
          if (area.scale !== 1.0) {
            transform += `scale(${area.scale}) `;
          }
          
          svgContent += `<path id="${area.id}" d="${area.path}" fill="${area.fill}" fill-opacity="${area.fillOpacity}" stroke="${area.stroke}" stroke-width="2" cursor="pointer"`;
          if (transform) {
            svgContent += ` transform="${transform.trim()}"`;
          }
          svgContent += ` />`;
        });
        
        svgContent += '</svg>';
        svgElement.innerHTML = svgContent;
        
        hoverAreas.forEach(area => {
          const pathElement = svgElement.querySelector(`#${area.id}`);
          if (!pathElement) return;
          
          const targetLayer = document.querySelector('.castle-layer.' + area.targetLayer);
          
          pathElement.addEventListener('mouseenter', () => {
            if (targetLayer) targetLayer.classList.add('highlighted');
            pathElement.style.opacity = '0.8';
          });
          
          pathElement.addEventListener('mouseleave', () => {
            if (targetLayer) targetLayer.classList.remove('highlighted');
            pathElement.style.opacity = '1';
          });
          
          if (area.navigateTo) {
            pathElement.addEventListener('click', () => {
              window.location.href = area.navigateTo;
            });
          }
        });
        
        hoverOverlay.appendChild(svgElement);
      }

      getPathBounds(pathData) {
        const numbers = pathData.match(/-?\d+\.?\d*/g);
        if (!numbers || numbers.length < 2) return { x: 0, y: 0, width: 100, height: 100 };
        
        const coords = numbers.map(n => parseFloat(n));
        let minX = coords[0], maxX = coords[0], minY = coords[1], maxY = coords[1];
        
        for (let i = 0; i < coords.length; i += 2) {
          if (i + 1 < coords.length) {
            minX = Math.min(minX, coords[i]);
            maxX = Math.max(maxX, coords[i]);
            minY = Math.min(minY, coords[i + 1]);
            maxY = Math.max(maxY, coords[i + 1]);
          }
        }
        
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }

      updateHoverSVGPosition() {
        // Update the hover SVG positioning based on current viewport
        const hoverOverlay = document.querySelector('.hover-overlay');
        const svgElement = hoverOverlay ? hoverOverlay.querySelector('.hover-box') : null;
        
        if (!svgElement) return;
        
        // Calculate scale factors for object-fit: cover
        const scaleX = window.innerWidth / this.originalWidth;
        const scaleY = window.innerHeight / this.originalHeight;
        const baseScale = Math.max(scaleX, scaleY);
        
        // Calculate scaled castle dimensions
        const scaledWidth = this.originalWidth * baseScale;
        const scaledHeight = this.originalHeight * baseScale;
        
        // Calculate position to match castle positioning
        const castleOffsetX = (window.innerWidth - scaledWidth) / 2;
        const castleOffsetY = (window.innerHeight - scaledHeight) / 2;
        
        // Position and size the SVG to exactly match the castle
        svgElement.style.left = castleOffsetX + 'px';
        svgElement.style.top = castleOffsetY + 'px';
        svgElement.style.width = scaledWidth + 'px';
        svgElement.style.height = scaledHeight + 'px';
        
        console.log('Castle: Updated hover SVG position', { scaledWidth, scaledHeight, castleOffsetX, castleOffsetY });
      }

      createCloud(isInitial, clouds, frontClouds, cloudIndex = 0) {
        const cloud = document.createElement('img');
        const randomCloud = this.cloudImages[Math.floor(Math.random() * this.cloudImages.length)];
        cloud.src = randomCloud;
        cloud.className = 'floating-cloud';
        
        // Random properties for depth effect
        const scale = Math.random() * 2;
        const opacity = Math.max(0.3, scale / 3);
        const speed = (2.5 - scale) * 130 + 30;
        const topPosition = Math.random() * 20 - 8;
        
        let startLeft, animationDuration, adjustedTopPosition;
        
        if (isInitial) {
          // Space out initial clouds based on their index and add some randomness
          const baseProgress = cloudIndex * 0.12; // Space clouds 12% apart
          const randomOffset = Math.random() * 0.1 - 0.05; // ±5% random variation
          const progress = Math.max(0, Math.min(baseProgress + randomOffset, 1));
          
          // Calculate position based on progress
          const startPosVw = 70;
          const endPosPx = -400;
          const endPosVw = (endPosPx / window.innerWidth) * 100;
          const totalDistance = startPosVw - endPosVw;
          startLeft = startPosVw - (progress * totalDistance);
          
          // Calculate remaining animation duration
          animationDuration = speed * (1 - progress);
          
          // Adjust Y position based on progress
          const verticalDrift = progress * 20;
          adjustedTopPosition = topPosition + verticalDrift;
        } else {
          // Normal clouds start from the right
          startLeft = 70;
          animationDuration = speed;
          adjustedTopPosition = topPosition;
        }
        
        cloud.style.cssText = `
          position: absolute;
          left: ${startLeft}vw;
          top: ${adjustedTopPosition - 20}vh;
          width: ${scale * 200}px;
          height: auto;
          opacity: ${opacity};
          pointer-events: none;
          rotate: -10deg;
          transition: all ${animationDuration}s linear;
        `;
        
        if (scale > 1 && topPosition < 10) {
          frontClouds.appendChild(cloud);
        } else {
          clouds.appendChild(cloud);
        }
        
        // Start animation
        setTimeout(() => {
          cloud.style.left = `-400px`;
          cloud.style.top = `${topPosition}vh`;
        }, 100);
        
        // Remove cloud after animation
        setTimeout(() => {
          if (cloud.parentNode) {
            cloud.parentNode.removeChild(cloud);
          }
        }, animationDuration * 1000 + 500);
      }

      scheduleNextCloud() {
        const delay = Math.random() * 2000 + 5000;
        setTimeout(() => {
          const clouds = document.getElementById('clouds');
          const frontClouds = document.getElementById('front-clouds');
          if (clouds && frontClouds) {
            this.createCloud(false, clouds, frontClouds);
            this.scheduleNextCloud();
          }
        }, delay);
      }
    }

    // Register the manager
    function registerCastleManager() {
      console.log('Attempting to register CastleManager...');
      console.log('SiegeApp available:', !!window.SiegeApp);
      console.log('SiegeBaseManager available:', typeof window.SiegeBaseManager);
      
      if (window.SiegeApp && typeof window.SiegeBaseManager !== 'undefined') {
        console.log('Registering CastleManager with SiegeApp');
        SiegeApp.registerManager('castle', new CastleManager());
      } else {
        console.log('SiegeApp or SiegeBaseManager not ready, retrying in 50ms...');
        // Wait for SiegeApp to be available
        setTimeout(registerCastleManager, 50);
      }
    }

    registerCastleManager();
  }

  // Wait for DOM and then initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCastle);
  } else {
    initializeCastle();
  }
</script>