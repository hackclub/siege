<% content_for :body_class, "chambers-page" %>

<% content_for :head do %>
  <style>
    html, body {
      overflow: hidden;
    }
    
    .chambers-container {
      width: 100vw;
      background: transparent;
      overflow: hidden;
    }
    
    .chambers {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100vw;
      height: 100vh;
    }
    
    .chambers-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      object-fit: cover;
      transition: filter 0.3s ease;
    }

    .chambers-layer:nth-child(1) { z-index: 1; }
    .chambers-layer:nth-child(2) { z-index: 2; }
    .chambers-layer:nth-child(3) { z-index: 3; }
    .chambers-layer:nth-child(4) { z-index: 4; }

    .chambers-layer.highlighted {
      filter: drop-shadow(4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(-4px 0 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 4px 0 rgba(245, 231, 183, 0.8)) drop-shadow(0 -4px 0 rgba(245, 231, 183, 0.8));
    }

    .hover-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 300;
    }
    
    .hover-box {
      position: absolute;
      pointer-events: none;
    }
    
    .hover-box svg {
      width: 100%;
      height: 100%;
      pointer-events: auto;
    }
    
    .hover-box svg path,
    .hover-box svg circle,
    .hover-box svg rect,
    .hover-box svg polygon {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .hover-box svg path:hover,
    .hover-box svg circle:hover,
    .hover-box svg rect:hover,
    .hover-box svg polygon:hover {
      opacity: 0.8;
    }

    .left-meeple-display {
      position: fixed;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      z-index: 150;
      pointer-events: auto;
    }

    .left-meeple-container {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .customization-sidebar {
      position: fixed;
      top: 0;
      right: -500px;
      width: 450px;
      height: 100vh;
      background: rgba(246, 236, 206, 0.98);
      border-left: 3px solid rgba(64, 43, 32, 0.75);
      backdrop-filter: blur(10px);
      z-index: 1001;
      transition: right 0.3s ease;
      overflow-y: auto;
      padding: 2rem;
      box-sizing: border-box;
    }

    .customization-sidebar.open {
      right: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid rgba(64, 43, 32, 0.3);
    }

    .sidebar-close {
      cursor: pointer;
      font-size: 1.5rem;
      color: #3b2a1a;
      padding: 0.5rem;
      border: none;
      background: none;
    }

    .sidebar-close:hover {
      opacity: 0.7;
    }

    .sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .sidebar-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .details-title {
      font-weight: 700;
      font-size: 2.25rem;
      margin-bottom: 1.5rem;
      color: #3b2a1a;
    }

    .details-content {
      padding: 0;
      margin: 0;
      background: transparent;
      box-shadow: none;
      border-radius: 0;
    }

    .details-field {
      margin-bottom: 1.25rem;
    }
    .details-field:last-of-type {
      margin-bottom: 1.75rem;
    }

    .details-label {
      display: block;
      color: #3b2a1a;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .details-value {
      color: #3b2a1a;
      font-size: 1.125rem;
    }

    .details-actions {
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }

    .meeple-preview {
      width: 150px;
      height: 150px;
      margin: 1rem 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: visible;
    }

    .meeple-preview img {
      width: 150px;
      height: 150px;
      object-fit: contain;
    }

    .color-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      max-width: 200px;
    }

    .color-option {
      width: 30px;
      height: 30px;
      border: 3px solid transparent;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s ease;
    }

    .color-option.active {
      border-color: #402b20;
    }

    .color-option.blue { background-color: #3b82f6; }
    .color-option.red { background-color: #ef4444; }
    .color-option.pink { background-color: #ec4899; }
    .color-option.green { background-color: #10b981; }
    .color-option.orange { background-color: #f97316; }
    .color-option.purple { background-color: #8b5cf6; }
    .color-option.cyan { background-color: #06b6d4; }
    .color-option.yellow { background-color: #eab308; }

    .color-option img {
      width: 60px;
      height: 60px;
      filter: brightness(0) invert(1);
      transform: translate(1px, -5px);
    }

    .cosmetics-grid {
      margin-top: 1rem;
    }

    .cosmetic-items {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 1rem;
    }

    .cosmetic-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      border: 3px solid rgba(64, 43, 32, 0.75);
      cursor: pointer;
      background: transparent;
      position: relative;
    }

    .cosmetic-item:hover {
      filter: brightness(0.95);
    }

    .cosmetic-item.equipped {
      border-width: 5px;
    }


    .cosmetic-image {
      width: 60px;
      height: 60px;
      object-fit: contain;
      margin-bottom: 0.5rem;
    }

    .cosmetic-name {
      font-size: 0.9rem;
      font-weight: 600;
      text-align: center;
      line-height: 1.3;
      word-break: break-word;
      margin-bottom: 0.25rem;
      color: #402b20;
    }

    .cosmetic-type {
      font-size: 0.7rem;
      text-align: center;
      color: #6b5b4a;
      text-transform: uppercase;
      font-weight: 500;
      letter-spacing: 0.5px;
    }
  </style>
<% end %>

<div class="chambers-container">
  <div class="chambers">
    <%= image_tag "chambers/chambers-background.webp", class: "chambers-layer" %>
    <%= image_tag "chambers/customize-character.webp", class: "chambers-layer customize-character" %>
    <%= image_tag "chambers/details.webp", class: "chambers-layer details" %>
		<%= image_tag "chambers/referrals.webp", class: "chambers-layer" %>
  </div>
</div>
<div class="hover-overlay">
  <!-- Hover boxes will be generated by JavaScript -->
</div>

<%= render 'chambers_navbar' %>


<div class="left-meeple-display" onclick="openCustomizationSidebar()">
	<div class="left-meeple-container" id="left-meeple-display-container">
		<!-- MeepleDisplay will render here -->
	</div>
</div>

<!-- Sidebar Overlay -->
<div class="sidebar-overlay" id="sidebar-overlay" onclick="closeCustomizationSidebar()"></div>

<!-- Customization Sidebar -->
<div class="customization-sidebar" id="customization-sidebar">
  <div class="sidebar-header">
    <h2 class="details-label">Customize Your Meeple</h2>
    <button class="sidebar-close" onclick="closeCustomizationSidebar()">&times;</button>
  </div>
  
  <div class="color-options">
    <% @meeple.unlocked_colors.each do |color| %>
      <div class="color-option <%= color %> <%= 'active' if @meeple.color == color %>" 
           data-color="<%= color %>" 
           onclick="updateMeepleColor('<%= color %>')">
        <img src="<%= image_path("meeple/meeple-#{color}.png") %>" alt="<%= color.capitalize %>" />
      </div>
    <% end %>
  </div>
  
  <div class="details-field">
    <strong class="details-label">Cosmetics:</strong>
    <% if @unlocked_cosmetics.any? %>
      <div class="cosmetics-grid">
        <div class="cosmetic-items">
          <% 
            # Flatten all cosmetics and sort by render order
            render_order = ['back', 'hat', 'eyes', 'front', 'neck', 'feet', 'cloak', 'face', 'left', 'right']
            all_cosmetics = []
            @unlocked_cosmetics.each do |cosmetic_type, meeple_cosmetics|
              meeple_cosmetics.each do |meeple_cosmetic|
                cosmetic = meeple_cosmetic.cosmetic
                is_equipped = @equipped_cosmetics[cosmetic_type]&.cosmetic == cosmetic
                all_cosmetics << {
                  meeple_cosmetic: meeple_cosmetic,
                  cosmetic: cosmetic,
                  cosmetic_type: cosmetic_type,
                  is_equipped: is_equipped,
                  sort_order: render_order.index(cosmetic_type) || 999
                }
              end
            end
            all_cosmetics.sort_by! { |item| item[:sort_order] }
          %>
          
          <% all_cosmetics.each do |item| %>
            <div class="cosmetic-item <%= 'equipped' if item[:is_equipped] %>" 
                 data-cosmetic-id="<%= item[:cosmetic].id %>" 
                 data-cosmetic-type="<%= item[:cosmetic_type] %>"
                 onclick="toggleCosmetic(<%= item[:cosmetic].id %>, '<%= item[:cosmetic_type] %>')">
              <% if item[:cosmetic].image.attached? %>
                <%= image_tag item[:cosmetic].image, alt: item[:cosmetic].name, class: "cosmetic-image" %>
              <% end %>
              <span class="cosmetic-name"><%= item[:cosmetic].name %></span>
            </div>
          <% end %>
        </div>
      </div>
    <% else %>
      <p class="details-value">No cosmetics unlocked yet</p>
    <% end %>
  </div>
</div>



<script>
function startAddressSetup() {
  showModalAlert('Starting identity verification... Please complete the verification in the popup window.', 'Verification Required');
  
  const authorizer = new SubmitAuthorizer();
  
  authorizer.authorize()
    .then(result => {
      // Use the identity data directly from the SubmitAuthorizer result
      if (result.verified && result.identityData) {
        // Process identity and address data on the server
        return fetch('/process_identity_and_address', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
          },
          body: JSON.stringify({ 
            identity_data: result.identityData,
            idv_rec: result.idvRec
          })
        });
      } else {
        throw new Error('Identity verification not completed');
      }
    })
    .then(response => response.json())
    .then(data => {
      switch (data.status) {
        case 'address_created':
          // All data collected, ask for optional shipping name
          hideModal();
          showShippingNameModalForSetup();
          break;
        case 'partial_data':
        case 'missing_address':
          // Need manual address setup
          window.location.href = data.redirect_url;
          break;
        case 'verified':
          // User already had address, reload page
          window.location.reload();
          break;
        case 'verification_failed':
        case 'error':
          throw new Error(data.message || 'Verification failed');
        default:
          throw new Error('Unknown response status');
      }
    })
    .catch(error => {
      console.error('Verification error:', error);
      if (error.message === 'Authorization cancelled by user') {
        showModalAlert('Identity verification was cancelled.', 'Verification Cancelled');
      } else {
        showModalAlert('Identity verification failed. Please try again or contact @Olive on slack.', 'Error');
      }
    });
}

// Shipping name modal for setup flow (reloads page after completion)
function showShippingNameModalForSetup() {
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modal-title');
  const modalMessage = document.getElementById('modal-message');
  const modalActions = document.getElementById('modal-actions');
  
  modalTitle.textContent = 'Almost done!';
  modalMessage.innerHTML = '';
  modalActions.innerHTML = '';
  
  // Create explanation text
  const explanationText = document.createElement('p');
  explanationText.textContent = 'Your address has been set up automatically. You can optionally set a preferred shipping name if you want packages sent to a different name than what\'s on your ID.';
  explanationText.style.cssText = 'font-size: 1rem; line-height: 1.5; margin-bottom: 1.5rem;';
  modalMessage.appendChild(explanationText);
  
  // Create input field with proper styling
  const fieldset = document.createElement('fieldset');
  fieldset.className = 'fieldset';
  fieldset.style.cssText = 'margin: 1.5rem 0;';
  
  const legend = document.createElement('legend');
  legend.className = 'fieldset-legend';
  legend.textContent = 'Preferred Shipping Name (Optional)';
  
  const underlineField = document.createElement('div');
  underlineField.className = 'underline-field';
  
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'text-input';
  input.placeholder = 'Leave blank to use your name from ID';
  
  underlineField.appendChild(input);
  fieldset.appendChild(legend);
  fieldset.appendChild(underlineField);
  modalMessage.appendChild(fieldset);
  
  // Create buttons
  const skipBtn = document.createElement('button');
  skipBtn.textContent = 'Skip';
  skipBtn.className = 'submit-button modal-button';
  skipBtn.addEventListener('click', () => {
    hideModal();
    window.location.reload(); // Reload to show updated chambers page
  });
  
  const continueBtn = document.createElement('button');
  continueBtn.textContent = 'Continue';
  continueBtn.className = 'submit-button modal-button';
  continueBtn.addEventListener('click', () => {
    const shippingName = input.value.trim();
    
    if (shippingName) {
      // Save shipping name
      fetch('/set_shipping_name', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({ shipping_name: shippingName })
      }).then(() => {
        hideModal();
        window.location.reload(); // Reload to show updated chambers page
      }).catch(() => {
        // Continue even if shipping name update fails
        hideModal();
        window.location.reload();
      });
    } else {
      // Skip shipping name
      hideModal();
      window.location.reload();
    }
  });
  
  modalActions.appendChild(skipBtn);
  modalActions.appendChild(continueBtn);
  
  modal.style.display = 'flex';
  document.body.style.overflow = 'hidden';
  
  // Focus input
  setTimeout(() => input.focus(), 100);
}
</script>

<script>
// Use window object to avoid redeclaration issues with Turbo navigation
window.colorPaths = window.colorPaths || {
  'blue': '<%= asset_path("meeple/meeple-blue.png") %>',
  'red': '<%= asset_path("meeple/meeple-red.png") %>',
  'pink': '<%= asset_path("meeple/meeple-pink.png") %>',
  'green': '<%= asset_path("meeple/meeple-green.png") %>',
  'orange': '<%= asset_path("meeple/meeple-orange.png") %>',
  'purple': '<%= asset_path("meeple/meeple-purple.png") %>',
  'cyan': '<%= asset_path("meeple/meeple-cyan.png") %>',
  'yellow': '<%= asset_path("meeple/meeple-yellow.png") %>'
};
const colorPaths = window.colorPaths;

function toggleCosmetic(cosmeticId, cosmeticType) {
  const cosmeticItem = document.querySelector(`[data-cosmetic-id="${cosmeticId}"]`);
  
  // Determine current equipped state dynamically
  const isEquipped = cosmeticItem.classList.contains('equipped');
  
  // Store original state in case we need to revert
  const originalEquippedItems = [];
  document.querySelectorAll('.cosmetic-item.equipped').forEach(item => {
    originalEquippedItems.push(item.dataset.cosmeticId);
  });
  
  if (isEquipped) {
    // Unequip the cosmetic - update UI optimistically
    cosmeticItem.classList.remove('equipped');
    
    // Update meeple display immediately
    updateMeepleDisplay();
    
    fetch('<%= chambers_path %>', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ meeple: { unequip_cosmetic_id: cosmeticId } })
    }).then(response => {
      if (response.ok) {
        console.log('Successfully unequipped cosmetic');
      } else {
        // Revert UI changes on server error
        cosmeticItem.classList.add('equipped');
        updateMeepleDisplay(); // Update again after revert
        console.error('Failed to unequip cosmetic - reverted UI');
        showErrorMessage('Failed to unequip cosmetic. Please try again.');
      }
    }).catch(error => {
      // Revert UI changes on network error
      cosmeticItem.classList.add('equipped');
      updateMeepleDisplay(); // Update again after revert
      console.error('Network error unequipping cosmetic:', error);
      showErrorMessage('Connection error. Please check your network and try again.');
    });
  } else {
    // Handle mutually exclusive cosmetics (back and cloak)
    if (cosmeticType === 'back' || cosmeticType === 'cloak') {
      // Unequip both back and cloak items
      const backItems = document.querySelectorAll(`[data-cosmetic-type="back"]`);
      const cloakItems = document.querySelectorAll(`[data-cosmetic-type="cloak"]`);
      backItems.forEach(item => item.classList.remove('equipped'));
      cloakItems.forEach(item => item.classList.remove('equipped'));
    } else {
      // Unequip other cosmetics of the same type - update UI optimistically
      const typeItems = document.querySelectorAll(`[data-cosmetic-type="${cosmeticType}"]`);
      typeItems.forEach(item => item.classList.remove('equipped'));
    }
    
    // Equip this cosmetic
    cosmeticItem.classList.add('equipped');
    
    // Update meeple display immediately
    updateMeepleDisplay();
    
    fetch('<%= chambers_path %>', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ meeple: { equip_cosmetic_id: cosmeticId } })
    }).then(response => {
      if (response.ok) {
        console.log('Successfully equipped cosmetic');
      } else {
        // Revert UI changes on server error
        revertCosmeticState(originalEquippedItems);
        updateMeepleDisplay(); // Update again after revert
        console.error('Failed to equip cosmetic - reverted UI');
        showErrorMessage('Failed to equip cosmetic. Please try again.');
      }
    }).catch(error => {
      // Revert UI changes on network error
      revertCosmeticState(originalEquippedItems);
      updateMeepleDisplay(); // Update again after revert
      console.error('Network error equipping cosmetic:', error);
      showErrorMessage('Connection error. Please check your network and try again.');
    });
  }
}

function revertCosmeticState(originalEquippedIds) {
  // Remove all equipped states
  document.querySelectorAll('.cosmetic-item').forEach(item => {
    item.classList.remove('equipped');
  });
  
  // Restore original equipped states
  originalEquippedIds.forEach(cosmeticId => {
    const item = document.querySelector(`[data-cosmetic-id="${cosmeticId}"]`);
    if (item) item.classList.add('equipped');
  });
  
  // Ensure back/cloak mutual exclusivity is maintained
  const backEquipped = document.querySelector('[data-cosmetic-type="back"].equipped');
  const cloakEquipped = document.querySelector('[data-cosmetic-type="cloak"].equipped');
  if (backEquipped && cloakEquipped) {
    // If both are equipped, keep only the back item (arbitrary choice)
    cloakEquipped.classList.remove('equipped');
  }
}

function showErrorMessage(message) {
  // Create a temporary error message
  const errorDiv = document.createElement('div');
  errorDiv.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #ef4444;
    color: white;
    padding: 1rem;
    border-radius: 8px;
    z-index: 1000;
    max-width: 300px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  `;
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  
  // Remove after 5 seconds
  setTimeout(() => {
    if (errorDiv.parentNode) {
      errorDiv.parentNode.removeChild(errorDiv);
    }
  }, 5000);
}

function updateMeepleColor(color) {
  const colorOptions = document.querySelectorAll('.color-option');
  
  // Store original color in case we need to revert
  const originalColor = document.querySelector('.color-option.active')?.dataset.color;
  
  // Update color options UI optimistically
  colorOptions.forEach(option => {
    option.classList.toggle('active', option.dataset.color === color);
  });
  
  // Update meeple display immediately
  updateMeepleDisplay();
  
  // Send request to server asynchronously
  fetch('<%= chambers_path %>', {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
    },
    body: JSON.stringify({ meeple: { color: color } })
  }).then(response => {
    if (response.ok) {
      console.log('Successfully updated meeple color');
    } else {
      // Revert UI changes on server error
      colorOptions.forEach(option => {
        option.classList.toggle('active', option.dataset.color === originalColor);
      });
      updateMeepleDisplay();
      console.error('Failed to update meeple color - reverted UI');
      showErrorMessage('Failed to update meeple color. Please try again.');
    }
  }).catch(error => {
    // Revert UI changes on network error
    colorOptions.forEach(option => {
      option.classList.toggle('active', option.dataset.color === originalColor);
    });
    updateMeepleDisplay();
    console.error('Network error updating meeple color:', error);
    showErrorMessage('Connection error. Please check your network and try again.');
  });
}

// Store cosmetic data for dynamic updates - avoid redeclaration with Turbo
window.cosmeticDatabase = window.cosmeticDatabase || {
  <% @unlocked_cosmetics.each do |type, meeple_cosmetics| %>
    <% meeple_cosmetics.each do |meeple_cosmetic| %>
      '<%= meeple_cosmetic.cosmetic.id %>': {
        id: '<%= meeple_cosmetic.cosmetic.id %>',
        name: '<%= meeple_cosmetic.cosmetic.name %>',
        type: '<%= type %>',
        image: {
          attached: <%= meeple_cosmetic.cosmetic.image.attached? %>,
          url: '<%= url_for(meeple_cosmetic.cosmetic.image) if meeple_cosmetic.cosmetic.image.attached? %>'
        }
      },
    <% end %>
  <% end %>
};
const cosmeticDatabase = window.cosmeticDatabase;

function updateMeepleDisplay() {
  console.log('updateMeepleDisplay called');
  
  // Get current equipped cosmetics from DOM with full data
  const equippedCosmetics = [];
  document.querySelectorAll('.cosmetic-item.equipped').forEach(item => {
    const cosmeticId = item.dataset.cosmeticId;
    const cosmeticData = cosmeticDatabase[cosmeticId];
    if (cosmeticData) {
      equippedCosmetics.push({
        equipped: true,
        cosmetic: cosmeticData
      });
    }
  });
  
  // Sort by proper render order: Back, Hat, Eyes, Front, Neck, Feet, Cloak, Face, Left, Right
  const renderOrder = ['back', 'hat', 'eyes', 'front', 'neck', 'feet', 'cloak', 'face', 'left', 'right'];
  equippedCosmetics.sort((a, b) => {
    const aIndex = renderOrder.indexOf(a.cosmetic.type) !== -1 ? renderOrder.indexOf(a.cosmetic.type) : 999;
    const bIndex = renderOrder.indexOf(b.cosmetic.type) !== -1 ? renderOrder.indexOf(b.cosmetic.type) : 999;
    return aIndex - bIndex;
  });

  const currentColor = document.querySelector('.color-option.active')?.dataset.color || 'blue';
  
  console.log('Update - equipped cosmetics:', equippedCosmetics);
  console.log('Update - current color:', currentColor);
  
  // Update meeple display
  const userData = {
    meeple: {
      color: currentColor,
      imageSrc: colorPaths[currentColor],
      meeple_cosmetics: equippedCosmetics
    }
  };
  
  console.log('Update - user data:', userData);
  
  const container = document.getElementById('left-meeple-display-container');
  console.log('Update - container:', container);
  
  if (container) {
    // Get current scaled dimensions
    const meepleContainer = document.querySelector('.left-meeple-container');
    const currentWidth = meepleContainer ? parseInt(meepleContainer.style.width) || 380 : 380;
    const currentHeight = meepleContainer ? parseInt(meepleContainer.style.height) || 440 : 440;
    
    console.log('Update - rendering meeple with dimensions:', currentWidth, currentHeight);
    if (typeof window.renderUnifiedMeeple === 'function') {
      const success = renderUnifiedMeeple(userData, container, null, null, currentWidth, currentHeight);
      if (success) {
        console.log('Update - meeple rendering complete using unified renderer');
      } else {
        console.log('Update - unified renderer failed, using direct MeepleDisplay');
        const meepleDisplay = new MeepleDisplay(userData, currentWidth, currentHeight);
        meepleDisplay.renderToHTML(container);
      }
    } else {
      const meepleDisplay = new MeepleDisplay(userData, currentWidth, currentHeight);
      meepleDisplay.renderToHTML(container);
      console.log('Update - meeple rendering complete using direct MeepleDisplay');
    }
  } else {
    console.error('Update - container not found!');
  }

  // Also update navbar meeple if it exists
  const navbarContainer = document.getElementById('navbar-meeple-container');
  if (navbarContainer) {
    console.log('Update - rendering navbar meeple');
    if (typeof window.renderUnifiedMeeple === 'function') {
      const success = renderUnifiedMeeple(userData, navbarContainer, null, null, 88, 105);
      if (success) {
        console.log('Update - navbar meeple rendering complete using unified renderer');
      } else {
        console.log('Update - navbar unified renderer failed, using direct MeepleDisplay');
        const navbarMeepleDisplay = new MeepleDisplay(userData, 88, 105);
        navbarMeepleDisplay.renderToHTML(navbarContainer);
      }
    } else {
      const navbarMeepleDisplay = new MeepleDisplay(userData, 88, 105);
      navbarMeepleDisplay.renderToHTML(navbarContainer);
      console.log('Update - navbar meeple rendering complete using direct MeepleDisplay');
    }
  }
}

// Initialize MeepleDisplay
function initializeChambersMeepleDisplay() {
  console.log('initializeChambersMeepleDisplay called');
  console.log('MeepleDisplay available:', typeof window.MeepleDisplay);
  
  const container = document.getElementById('left-meeple-display-container');
  console.log('Left meeple container:', container);
  
  if (typeof window.MeepleDisplay === 'undefined') {
    console.log('MeepleDisplay not loaded yet, retrying in 100ms');
    setTimeout(initializeChambersMeepleDisplay, 100);
    return;
  }

  const equippedCosmetics = [
    <% @equipped_cosmetics.each do |type, meeple_cosmetic| %>
      {
        equipped: true,
        cosmetic: {
          id: '<%= meeple_cosmetic.cosmetic.id %>',
          name: '<%= meeple_cosmetic.cosmetic.name %>',
          type: '<%= type %>',
          image: {
            attached: <%= meeple_cosmetic.cosmetic.image.attached? %>,
            url: '<%= url_for(meeple_cosmetic.cosmetic.image) if meeple_cosmetic.cosmetic.image.attached? %>'
          }
        }
      },
    <% end %>
  ];

  const userData = {
    meeple: {
      color: '<%= @meeple.color %>',
      imageSrc: '<%= image_path("meeple/meeple-#{@meeple.color}.png") %>',
      meeple_cosmetics: equippedCosmetics
    }
  };
  
  console.log('Chambers user data:', userData);
  
  if (container) {
    console.log('Rendering to left meeple container');
    
    // Get current scaled dimensions
    const meepleContainer = document.querySelector('.left-meeple-container');
    const currentWidth = meepleContainer ? parseInt(meepleContainer.style.width) || 200 : 200;
    const currentHeight = meepleContainer ? parseInt(meepleContainer.style.height) || 240 : 240;
    
    console.log('Initialize - rendering meeple with dimensions:', currentWidth, currentHeight);
    if (typeof window.renderUnifiedMeeple === 'function') {
      const success = renderUnifiedMeeple(userData, container, null, null, currentWidth, currentHeight);
      if (success) {
        console.log('Left meeple rendering complete using unified renderer');
      } else {
        console.log('Left unified renderer failed, using direct MeepleDisplay');
        const meepleDisplay = new MeepleDisplay(userData, currentWidth, currentHeight);
        meepleDisplay.renderToHTML(container);
      }
    } else {
      const meepleDisplay = new MeepleDisplay(userData, currentWidth, currentHeight);
      meepleDisplay.renderToHTML(container);
      console.log('Left meeple rendering complete using direct MeepleDisplay');
    }
  } else {
    console.error('Left meeple container not found!');
  }

  // Also render meeple in navbar if it exists
  const navbarContainer = document.getElementById('navbar-meeple-container');
  if (navbarContainer) {
    console.log('Rendering to navbar container');
    if (typeof window.renderUnifiedMeeple === 'function') {
      const success = renderUnifiedMeeple(userData, navbarContainer, null, null, 88, 105);
      if (success) {
        console.log('Navbar meeple rendering complete using unified renderer');
      } else {
        console.log('Navbar unified renderer failed, using direct MeepleDisplay');
        const navbarMeepleDisplay = new MeepleDisplay(userData, 88, 105);
        navbarMeepleDisplay.renderToHTML(navbarContainer);
      }
    } else {
      const navbarMeepleDisplay = new MeepleDisplay(userData, 88, 105);
      navbarMeepleDisplay.renderToHTML(navbarContainer);
      console.log('Navbar meeple rendering complete using direct MeepleDisplay');
    }
  }
}

document.addEventListener('DOMContentLoaded', function() {
  initializeChambersMeepleDisplay();
});

document.addEventListener('turbo:load', function() {
  console.log('turbo:load fired on chambers page');
  initializeChambersMeepleDisplay();
});

// Sidebar Functions
function openCustomizationSidebar() {
  const sidebar = document.getElementById('customization-sidebar');
  const overlay = document.getElementById('sidebar-overlay');
  
  if (sidebar) sidebar.classList.add('open');
  if (overlay) overlay.classList.add('open');
  document.body.style.overflow = 'hidden';
}

function closeCustomizationSidebar() {
  const sidebar = document.getElementById('customization-sidebar');
  const overlay = document.getElementById('sidebar-overlay');
  
  if (sidebar) sidebar.classList.remove('open');
  if (overlay) overlay.classList.remove('open');
  document.body.style.overflow = '';
}

// Details Modal Functions
function showDetailsModal() {
  <% if @address.present? %>
    let message = `<div style="text-align: left; font-size: 1.1rem; line-height: 1.6;">
      <div style="margin-bottom: 1rem;"><strong>Name:</strong> <%= @address.first_name %> <%= @address.last_name %></div>
      <div style="margin-bottom: 1rem;"><strong>Birthday:</strong> <%= @address.birthday.strftime("%B %d, %Y") if @address.birthday %></div>
      <% if @address.shipping_name.present? %>
        <div style="margin-bottom: 1rem;"><strong>Preferred Shipping Name:</strong> <%= @address.shipping_name %></div>
      <% end %>
      <div style="margin-bottom: 1rem;"><strong>Address:</strong><br>
        <%= @address.line_one %><br>
        <% if @address.line_two.present? %><%= @address.line_two %><br><% end %>
        <%= @address.city %>, <%= @address.state %> <%= @address.postcode %><br>
        <%= @address.human_country %>
      </div>
    </div>`;
    
    showModal('Your Details', '', [
      { text: 'Edit Details', primary: true, action: () => { window.location.href = '<%= edit_chambers_path %>'; } },
      { text: 'Close', action: () => {} }
    ]);
    
    // Set the message as HTML
    const modalMessage = document.getElementById('modal-message');
    if (modalMessage) {
      modalMessage.innerHTML = message;
    }
  <% else %>
    showModal('Your Details', 'Complete your account setup to participate fully in Siege.', [
      { text: 'Finish Setup', primary: true, action: () => { startAddressSetup(); } },
      { text: 'Close', action: () => {} }
    ]);
  <% end %>
}

// Chambers page initialization handled by ChambersManager

// Register Chambers Manager
(function() {
  const chambersElement = document.querySelector('.chambers');
  if (!chambersElement) return; // Not on chambers page

  class ChambersManager extends SiegeBaseManager {
    constructor() {
      super('Chambers');
      this.originalWidth = 1920;
      this.originalHeight = 1080;
      this.meepleConfig = {
        x: 350,
        y: 330,
        width: 200,
        height: 240,
        scale: 1.8
      };
    }

    initialize() {
      console.log('Chambers: Initializing...');
      
      try {
        this.setupClickSystem();
        this.setupMeepleSystem();
        
        this.isValid = true;
        return true;
      } catch (error) {
        console.error('Chambers: Initialization failed:', error);
        return false;
      }
    }

    validate() {
      return this.isValid && 
             document.querySelector('.chambers') &&
             document.querySelector('.hover-overlay');
    }

    setupClickSystem() {
      const hoverOverlay = document.querySelector('.hover-overlay');
      if (!hoverOverlay) return;
      
      hoverOverlay.innerHTML = ''; // Clear existing
      
      this.createHoverSVG();
      this.updateHoverSVGPosition();
      
      this.addEventListener(window, 'resize', () => {
        this.updateHoverSVGPosition();
        this.updateMeeplePosition();
      });
    }

    setupMeepleSystem() {
      this.updateMeeplePosition();
      
      if (typeof initializeChambersMeepleDisplay === 'function') {
        initializeChambersMeepleDisplay();
      }
    }

    createHoverSVG() {
      const hoverOverlay = document.querySelector('.hover-overlay');
      const svgElement = document.createElement('div');
      svgElement.className = 'hover-box';
      
      const clickAreas = [
        {
          id: 'details',
          path: `M57.5 58L1 119.5V165L40 175L52 198.5H66V282L57.5 299.5L79.5 316L113.5 309.5L265 322L311.5 332L327.5 322L316.5 309.5L327.5 221L362.5 207L356.5 182.5L392.5 175L386 126L321 15.5L135 1L57.5 58Z`,
          fill: "#E40000",
          fillOpacity: "0",
          stroke: "",
          x: 1085,
          y: 645,
          scale: 1,
          targetLayer: 'details',
          action: 'showDetailsModal'
        },
        {
          id: 'customization',
          path: `M78.5 365.5L1 356.5V337.5L29 316.5L18 240.5H50.5L43.5 119L34.5 56.5L56 47L74 12.5L105 1.5L155.5 89L187.5 56.5L226 47L293.5 6L327 1.5L371.5 52V250.5L341 292.5L327 379.5H226L78.5 365.5Z`,
          fill: "#0000E4",
          fillOpacity: "0",
          stroke: "",
          x: 510,
          y: 525,
          scale: 1,
          targetLayer: 'customize-character',
          action: 'openCustomizationSidebar'
        }
      ];
      
      let svgContent = `<svg width="100%" height="100%" viewBox="0 0 ${this.originalWidth} ${this.originalHeight}" xmlns="http://www.w3.org/2000/svg">`;
      
      clickAreas.forEach(area => {
        let transform = '';
        if (area.x !== 0 || area.y !== 0) {
          transform += `translate(${area.x}, ${area.y}) `;
        }
        if (area.scale !== 1.0) {
          transform += `scale(${area.scale}) `;
        }
        
        svgContent += `<path id="${area.id}" d="${area.path}" fill="${area.fill}" fill-opacity="${area.fillOpacity}" stroke="${area.stroke}" stroke-width="2" cursor="pointer"`;
        if (transform) {
          svgContent += ` transform="${transform.trim()}"`;
        }
        svgContent += ` />`;
      });
      
      svgContent += '</svg>';
      svgElement.innerHTML = svgContent;
      
      clickAreas.forEach(area => {
        const pathElement = svgElement.querySelector(`#${area.id}`);
        if (pathElement && window[area.action]) {
          const targetLayer = document.querySelector('.chambers-layer.' + area.targetLayer);
          
          this.addEventListener(pathElement, 'mouseenter', () => {
            if (targetLayer) targetLayer.classList.add('highlighted');
            pathElement.style.opacity = '0.8';
          });
          
          this.addEventListener(pathElement, 'mouseleave', () => {
            if (targetLayer) targetLayer.classList.remove('highlighted');
            pathElement.style.opacity = '1';
          });
          
          this.addEventListener(pathElement, 'click', () => {
            window[area.action]();
          });
        }
      });
      
      hoverOverlay.appendChild(svgElement);
    }

    updateHoverSVGPosition() {
      const hoverBox = document.querySelector('.hover-box');
      if (!hoverBox) return;
      
      const scaleX = window.innerWidth / this.originalWidth;
      const scaleY = window.innerHeight / this.originalHeight;
      const baseScale = Math.max(scaleX, scaleY);
      
      const scaledWidth = this.originalWidth * baseScale;
      const scaledHeight = this.originalHeight * baseScale;
      
      const chambersOffsetX = (window.innerWidth - scaledWidth) / 2;
      const chambersOffsetY = (window.innerHeight - scaledHeight) / 2;
      
      hoverBox.style.left = chambersOffsetX + 'px';
      hoverBox.style.top = chambersOffsetY + 'px';
      hoverBox.style.width = scaledWidth + 'px';
      hoverBox.style.height = scaledHeight + 'px';
    }

    updateMeeplePosition() {
      const meepleDisplay = document.querySelector('.left-meeple-display');
      const meepleContainer = document.querySelector('.left-meeple-container');
      if (!meepleDisplay || !meepleContainer) return;
      
      const scaleX = window.innerWidth / this.originalWidth;
      const scaleY = window.innerHeight / this.originalHeight;
      const baseScale = Math.max(scaleX, scaleY);
      
      const scaledWidth = this.originalWidth * baseScale;
      const scaledHeight = this.originalHeight * baseScale;
      
      const chambersOffsetX = (window.innerWidth - scaledWidth) / 2;
      const chambersOffsetY = (window.innerHeight - scaledHeight) / 2;
      
      const scaledMeepleX = (this.meepleConfig.x * baseScale * this.meepleConfig.scale) + chambersOffsetX;
      const scaledMeepleY = (this.meepleConfig.y * baseScale * this.meepleConfig.scale) + chambersOffsetY;
      const scaledMeepleWidth = this.meepleConfig.width * baseScale * this.meepleConfig.scale;
      const scaledMeepleHeight = this.meepleConfig.height * baseScale * this.meepleConfig.scale;
      
      meepleDisplay.style.left = scaledMeepleX + 'px';
      meepleDisplay.style.top = scaledMeepleY + 'px';
      
      meepleContainer.style.width = scaledMeepleWidth + 'px';
      meepleContainer.style.height = scaledMeepleHeight + 'px';
      
      // Re-render meeple with new dimensions
      if (typeof updateMeepleDisplay === 'function') {
        updateMeepleDisplay();
      }
    }
  }

  // Register the manager
  function registerChambersManager() {
    if (window.SiegeApp && typeof window.SiegeBaseManager !== 'undefined') {
      SiegeApp.registerManager('chambers', new ChambersManager());
    } else {
      // Wait for SiegeApp to be available
      setTimeout(registerChambersManager, 50);
    }
  }

  registerChambersManager();
})();

// Legacy wrapper for existing code
window.updateMeeplePosition = function() {
  const manager = SiegeApp?.managers?.get('chambers');
  if (manager && typeof manager.updateMeeplePosition === 'function') {
    manager.updateMeeplePosition();
  }
};
</script>
